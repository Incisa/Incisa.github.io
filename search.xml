<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue-Cli 脚手架快速搭建笔记]]></title>
    <url>%2F2017%2F07%2F16%2Fvue-cli%20%E6%90%AD%E6%9E%B6%E5%AD%90%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[搭一遍忘一遍查一遍搭一遍在这里记下来查的时候方便点 vue-cli 作用vue-cli 作为 vue 的脚手架，可以帮助我们在实际开发中自动生成 vue.js 的模板工程。 vue-cli 使用方法!!! 前提：需要 vue 和 webpack（不必多说） 安装全局 vue-cli 1npm install vue-cli -g 初始化，生成项目模板（my_project 是项目名，自己随意） 1vue init webpack my_project 这个时候会有一些提示：告诉你现在安装的是 Vue2.x 版本的模板什么的，之后输入项目名、项目描述、作者名称。 之后会让你选择 Runtime + Complter 还是只安装 Runtime，选择 Runtime Only 会节约 6kb 空间但是会缺少编译器，会依赖.Vue 文件的开发。 提示是否安装 Vue-Router 提示是否使用 ESlint 规范代码书写。 提示是否需要测试相关组件 Karma + mocha 提示是否需要测试相关组件 e2e tests 进入生成的项目文件夹 1cd my_project 初始化，安装依赖 1npm install 本地 run 1npm run dev 即可看见本地搭建的脚手架服务器，浏览器会自动弹出初始页面。 在服务器上运行1npm run build]]></content>
  </entry>
  <entry>
    <title><![CDATA[WebSocket 入门知识]]></title>
    <url>%2F2017%2F07%2F14%2FWebSocket%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[WebSocket 是伴随 HTML5 出现的一款新技术，他和传统的 HTTP 协议有所不同。（P.S. 我个人认为他仅仅是个协议。也就是说 HTTP 协议没有变化，或者说没关系，但 HTTP 是不支持持久连接的（长连接，循环连接的不算） WebSocket 机制WebSocket 是 HTML5 下一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与 HTTP 一样通过已建立的 TCP 连接来传输数据，但是它和 HTTP 最大不同是： WebSocket 是一种双向通信协议。在建立连接后，WebSocket 服务器端和客户端都能主动向对方发送或接收数据，就像 Socket 一样； WebSocket 需要像 TCP 一样，先建立连接，连接成功后才能相互通信。 传统 HTTP 客户端与服务器请求响应模式如下图所示： WebSocket 模式客户端与服务器请求响应模式如下图： 由上图对比可以看出，相对于传统 HTTP 每次请求 - 应答都需要客户端与服务端建立连接的模式，WebSocket 是类似 Socket 的 TCP 长连接通讯模式。一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 WebSocket 连接或 Server 端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。 WebSocket 特点相比 HTTP 长连接，WebSocket 有以下特点： 是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而 HTTP 长连接基于 HTTP，是传统的客户端对服务器发起请求的模式。 HTTP 长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换 HTTP header，信息交换效率很低。Websocket 协议通过第一个 request 建立了 TCP 连接之后，之后交换的数据都不需要发送 HTTP header 就能交换数据，这显然和原有的 HTTP 协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持 HTML5）。此外还有 multiplexing、不同的 URL 可以复用同一个 WebSocket 连接等功能。这些都是 HTTP 长连接不能做到的。 WebSocket 报文在客户端，new WebSocket 实例化一个新的 WebSocket 客户端对象，请求类似 ws://yourdomain:port/path 的服务端 WebSocket URL，客户端 WebSocket 对象会自动解析并识别为 WebSocket 请求，并连接服务端端口，执行双方握手过程，客户端发送数据格式类似： 1234567GET /webfin/websocket/ HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==Origin: http://localhost:8080Sec-WebSocket-Version: 13 可以看到，客户端发起的 WebSocket 连接报文类似传统 HTTP 报文，Upgrade：websocket 参数值表明这是 WebSocket 类型请求，Sec-WebSocket-Key 是 WebSocket 客户端发送的一个 base64 编码的密文，要求服务端必须返回一个对应加密的 Sec-WebSocket-Accept 应答，否则客户端会抛出 Error during WebSocket handshake 错误，并关闭连接。 服务端收到报文后返回的数据格式类似： 1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8= Sec-WebSocket-Accept 的值是服务端采用与客户端一致的密钥计算出来后返回客户端的，HTTP/1.1 101 Switching Protocols 表示服务端接受 WebSocket 协议的客户端连接，经过这样的请求 - 响应处理后，两端的 WebSocket 连接握手成功, 后续就可以进行 TCP 通讯了。用户可以查阅 WebSocket 协议栈了解 WebSocket 客户端和服务端更详细的交互数据格式。 WebSocket API 的使用以下简单举个例子。 12345678910111213141516171819202122// 创建一个 Socket 实例var socket = new WebSocket('ws://echo.Websocket.org') // 里面是 WebSocket 服务器// 打开 Socket socket.onopen = function(event) &#123; // 发送一个初始化消息 socket.send('I am the client and I\'m listening!') // 监听消息 socket.onmessage = function(event) &#123; console.log('Client received a message',event) &#125; // 监听 Socket 的关闭 socket.onclose = function(event) &#123; console.log('Client notified socket has closed',event) &#125; // 关闭 Socket.... //socket.close() &#125; 用 Node 搭建自己的 WebSocket 服务 gitHub: https://github.com/sitegui/nodejs-websocket 安装 npm install nodejs-websocket 12345678910111213var ws = require("nodejs-websocket")// Scream server example: "hi" -&gt; "HI!!!"var server = ws.createServer(function (conn) &#123; console.log("New connection") conn.on("text", function (str) &#123; console.log("Received "+str) conn.sendText(str.toUpperCase()+"!!!") &#125;) conn.on("close", function (code, reason) &#123; console.log("Connection closed") &#125;)&#125;).listen(8001) 这样遍简单的搭建了一个 Websocket 服务器，会把小写的字母变成大写并加上三个感叹号。 参考资料 慕课网 http://www.imooc.com/video/15316 腾讯云产品文档 https://www.qcloud.com/document/product/214/4150?fromSource=gwzcw.93403.93403.93403 知乎回答 https://www.zhihu.com/question/20215561 阮一峰博客教程 http://www.ruanyifeng.com/blog/2017/05/websocket.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[类数组对象（Array-like Object）知识]]></title>
    <url>%2F2017%2F07%2F05%2FArray-like%20Object%2F</url>
    <content type="text"><![CDATA[又是一个突然发现好像有点懵逼的东西。 定义什么是类数组呢？ 拥有 length 属性，其它属性（索引）为非负整数 (对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解) 不具有数组所具有的方法 P.S. 大概就是只要有 length 属性，且它的属性值为 number 类型就是类数组了呗？ 举个例子 12345// 这也算是类数组。var a = &#123;'1':'gg','2':'love','4':'meimei',length:5&#125;// 类数组使用数组方法Array.prototype.join.call(a,'+') //'+gg+love++meimei' JavaScript 中常见的类数组 DOM 元素 Arguments 对象 类数组的存在原因类数组之所以存在，主要有 2 点原因。 万物皆对象（所有对象都继承于 Object。所以都能调用对象的方法，比如使用点和方括号访问属性。） 鸭子类型（如果它走起来像鸭子，而且叫起来像鸭子，那么它就是鸭子。） 类数组与数组的转换《javascript 权威指南》上给出了代码用来判断一个对象是否属于 “类数组”。12345678910111213141516171819// Determine if o is an array-like object.// Strings and functions have numeric length properties, but are // excluded by the typeof test. In client-side JavaScript, DOM text// nodes have a numeric length property, and may need to be excluded // with an additional o.nodeType != 3 test.function isArrayLike(o) &#123; if (o &amp;&amp; // o is not null, undefined, etc. typeof o === 'object' &amp;&amp; // o is an object isFinite(o.length) &amp;&amp; // o.length is a finite number o.length &gt;= 0 &amp;&amp; // o.length is non-negative o.length===Math.floor(o.length) &amp;&amp; // o.length is an integer o.length &lt; 4294967296) &#123; return true; // Then o is array-like &#125; // o.length &lt; 2^32 else &#123; return false; // Otherwise it is not &#125;&#125; 那么，如果类数组对象需要转化为数组，可以用 Array.prototype.slice.call 12345678// An array-like objectvar a = &#123;'0':'a', '1':'b', '2':'c', length:3&#125;Array.prototype.join.call(a, '+') // =&gt; 'a+b+c'Array.prototype.slice.call(a, 0) // =&gt; ['a','b','c']: true array copyArray.prototype.map.call(a, function(x) &#123; return x.toUpperCase()&#125;) // =&gt; ['A','B','C']: 这样，就可以获得数组的方法，当然输出结果也会变成数组。]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础详细复习（二）]]></title>
    <url>%2F2017%2F06%2F30%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A002%2F</url>
    <content type="text"><![CDATA[继续前篇，本期以 http 协议为主。 HTTP 协议HTTP 协议和 TCP/IP 协议族内的其他众协议相同，用于客户端和服务器之间的通信。两台计算机之间使用 HTTP 协议通信时，必定是一端担任客户端角色，另一端担任服务器端角色 HTTP 协议规定，请求从客户端发出，最后服务器端相应该请求并返回。换句话说，肯定是先从客户端开始建立通信，服务器端在没有接收到请求之前不会发送响应。 HTTP 是应用层协议，主要解决如何包装数据。关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用 (传输层) TCP/IP 协议，但是那样的话，如果没有应用层，便无法识别数据内容。”或者说：“tcp 协议可以让两个进程通过三次握手建立稳定的通信信道，发送字节流，而 http 协议建立在 tcp 协议之上，也就是说 tcp 协议可以让两个程序说话，而 http 协议定义了说话的规则。” 请求和响应交换达成通信发送请求：12345GET index.html HTTP/1.1Host: hackr.jpConnection: Keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 16 起始行开头的 GET 请求表示请求访问服务器的类型，称为方法。随后的字符串 index.html 指明了请求的访问对象，也叫做请求 URI（request-URI）。最后的 HTTP/1.1，即 HTTP 的版本号。请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。 发送响应：123456HTTP/1.1 200 OKDate: Tue, 10 Jul 2012 06:50:15 GMTContent-Length: 362Content-Type: text/html&lt;html&gt;... 响应报文基本由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。 HTTP是不保存状态的协议HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议对于发送过的请求或响应都不做持久化处理。 对于无状态的理解： 协议对于事务处理没有记忆能力 对同一个 url 请求没有上下文关系 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 有关无状态的深入理解请点击此链接 HTTP 协议设计成无状态是为了更快的处理大量事物，确保协议的可伸缩性，才将 HTTP 协议设计成如此简单。随着需求增加，因为无状态导致业务处理变得棘手，为了实现保持状态功能，于是引用了 cookie 技术。 HTTP 方法GET：获取资源 GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI（Common Gateway INterface，通用网关接口）那样的程序，则返回经过执行后的输出结果。 POST：传输实体主体 虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。 有关于 GET 和 POST 的区别：最明显的还是语义上的不同。GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader 的约束）,GET 方法的报文主体没有任何语义。POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。 另有：PUT（传输文件）、HEAD（获得报文首部）、DELETE（删除文件）、OPTIONS（询问支持的方法）、TRACE（追踪路径）、CONNECT（要求用隧道协议连接代理）方法，详情《图解HTTP》第 2.5 章节 持久连接HTTP 协议的初始版本中每进行一次 HTTP 通信就要断开一次 TCP 连接。然而使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里的其他资源。每次请求都会造成无谓的 TCP 连接和断开，增加通信量开销。 为了解决上述 TCP 问题，HTTP/1.1 和一部分 HTTP/1.0 想出了持久连接（HTTP Persisent Connections，也称为 HTTP Keep-alive 或 HTTP Connection reuse） 的方法。持久连接的特点是，只要一端没有明确提出断开连接，则保持 TCP 连接状态。 持久连接的优点是在于减少了 TCP 连接的重复建立和断开造成的额外开销，减轻了服务器端的负载。另外减少开销的那部分时间，使 HTTP 请求和响应能够更早的结束，使 Web 页面的显示速度也相应提高。 在 HTTP/1.1 中所有连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。 管线化持久连接使得多数请求以管线化（pipelining） 方式发送成为可能。以前发送请求后需要等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可发送下一个请求。这样就可以做到同时并行发送多个请求，而不需要一个一个等待响应。 使用 cookie 进行状态管理因为 HTTP 协议的无状态特点，自然可以减少服务器的 CPU 及内存资源的消耗。保留无状态协议这个特征又要解决需要保留状态的需求的矛盾问题，于是引用了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 Cookie会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中假如 Cookie 值后发送出去。 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础详细复习（一）]]></title>
    <url>%2F2017%2F06%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A001%2F</url>
    <content type="text"><![CDATA[起源于一次面试，发现自己关于计算机网络基础内容记忆和理解不够深刻。在此总结一下，依照《图解http》这本书内容为主，强化记忆和理解 网络基础、TCP/IP 协议族 每台接入互联网的电脑都有一个 IP 地址 ipv4：互联网协议版本 4（Internet Protocol version 4，IPv4），又称互联网通信协议第四版，是互联网协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本 即使 ipv4 拥有 43 亿个地址，但是也出现了不够用情况 网络地址转换（Network Address Translation，缩写为 NAT）出现了 局域网 pc 通过 NAT 协议来连接互联网 访问一个网站，其实就是在与互联网上的另一台计算机通信。而通信肯定需要知道那台电脑的具体 IP 地址，就像打电话需要知道那个人的电话号码一样。然而，我们访问的时候，并没有告诉浏览器 Google 的服务器的 IP 地址。 那浏览器是如何知道的呢？很明显，这个 IP 地址信息隐藏在了上面的网址里面。 域名(Domain Name)，就像手机里的电话本，IP 地址，就像某条通信录的电话，那么上面网上的哪一部分隐藏了服务器的 IP 地址呢？？？很明显，是 www.google.com 这一部分，这个部分叫做 “域名” 计算机（浏览器）如何得到这个域名所代表的 ip 地址呢？以及，为什么要有域名呢？ ip 地址很明显比较难记，而且也没有太明显的具体意义 所以给 ip 地址起个名字就显得有必要了 而这个名字就是域名了 所以，一个域名就代表了一个 ip，而后代表了一台接入互联网的计算机 几个特殊的 IP 地址 127.0.0.1 总是代表当前计算机 两台计算机之间通信，理所当然需要使用一个双方都明白的 “规则”，就像你去邮局写信，需要按照指定的格式把必要的信息写在信封一样。因为很显然，通过电线，只能传输电信号，每一个电信号代表什么意思就成了至关重要的事情了。而电线可以传输高电位与低电位，就可以用这两种状态分别代表 0 和 1，就是二进制。于是，世界形成了。 而我们把这种通信规则成为：协议（protocol） 我们通常使用的网络（包括互联网）则是在 TCP/IP 协议族 的基础上运作的，而 HTTP 则是它内部的一个子集 TCP/IP 是互联网相关的各类协议族的总称，里面包括：IEEE 802.3、FDDI、ICMP、TCP、IP、HTTP、FTP、DNS、PPPoE、SNMP、UDP 等。一般来说，一个协议往往是基于其它协议的。 TCP/IP 的分层管理 TCP/IP 协议族里最重要的一点就是分层。TCP/IP 协议族按照层次分别分为以下 4 层： 应用层 传输层 网络层 数据链路层 TCP/IP 层次化的优点： 互联网只有一个协议统筹的话，当某个地方需要重新设计，则必须把所有部分整体替换掉。而分层之后只需把需要变动的层替换掉即可。并且设计也变得简单，每个层次只需要解决自己层面的问题而不用考虑整体。 应用层： 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。HTTP 协议也处于该层。 传输层： 传输层对上层应用层，提供处于网络；连接中两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议） 网络层（又名网络互连层）： 网络层用来处理网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或者网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。 链路层（又名数据链路层、网络接口层）： 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器、即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。 TCP/IP 通信传输流 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，接收端则从应用层往上走。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没进过一层时会把对应的首部消去。 这种把信息包装起来的做法叫做封装（encapsulate） 与 HTTP 关系密切的协议：IP、TCP 和 DNS负责传输的 IP 协议 IP（Internet Protocol）网络协议位于位于网络层。Internet Protocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称。 IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）。 IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。 确保可靠性的 TCP 协议 互联网最重要的协议是 TCP 协议（Transmition Control Protocol传输控制协议）（很遗憾不是 HTTP，不过 HTTP 是使用最广泛的协议） 按层次分，TCP 位于传输层，提供可靠的字节流服务。 字节流服务（Byte Stresam Sevice）:为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。 而可靠的传输服务是指，能够把数据准确可靠的传送给对方。TCP 协议是为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方 TCP 协议把两台计算机的通信抽象成了一组很简单的接口（函数） send(ip, content) content = read() 两台计算机之间建立起了 TCP 连接后就像有一个管道连接在两台计算机之间。而为了准确无误的将数据送达目标处，TCP协议采用了三次握手（three-way handshaking）策略。而数据保证发送成功肯定是需要一个反馈。这种反馈叫做 ACK（即确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误）。事实上并不是两台计算机在通信，而是两台计算机上的程序在通信。 发送端首先发送一个带有 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 负责域名解析的的 DNS 服务 计算机通过 DNS 服务（Domain Name Service）来得到一个域名所对应的 ip 地址。它和 HTTP 协议一样是位于应用层的协议，它提供域名到 IP 地址之间的解析服务。DNS 服务器需要预先配置在电脑里， DNS 服务器的地址我们需要以 ip 地址的形式告诉计算机。 各种协议在各自的层面上分别发挥各自的功能。]]></content>
  </entry>
  <entry>
    <title><![CDATA[作用域和闭包]]></title>
    <url>%2F2017%2F06%2F20%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[作用域，作用域，作用域。坑爹的地方说三遍。（《你所不知道的 JavaScript》 是一本好书哦） 作用域在正式说到作用域之前，先提一下编译原理 我们尽管通常将 JavaScript 归类为 “动态”、“解释执行”语言，但是它依旧是一门编译语言。在传统的编译语言的流程中，程序中的一段代码通常会经历三个步骤： 分词/词法分析 -&gt; 解析/语法分析 -&gt; 代码生成。 简单来说，任何 JavaScript 代码片段在执行前都要进行编译，我们举个例子： 1var a = 2 这一句，会被分解成有意义的代码块，我们称为语法单元（token），分解后就是：var 、 a 、 = 、 2。而空格是否会被当作词法单元，取决于空格在这门语言中是否有意义。 而在 JavaScript 中，对于 var a = 2 进行处理的时候，就会有 引擎、编译器、还有作用域的参与。 引擎：从头到尾负责整个 Javascript 程序的编译及执行过程。 编译器：负责语法分析及代码生成等。 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符（变量）的访问权限。 当遇到 var a 时，编译器会从作用域中寻找是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会自动忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a 。 接下来编译器会为引擎生成运行时所需的代码，这些代码用来处理 a = 2 这个赋值操作。引擎运行时会首先从作用域中查找 当前作用域集合中是否存在 变量 a。如果有，引擎就会使用这个变量。如果没有，引擎就会继续向上一级作用域集合中查找改变量。 总结： 变量的赋值操作分两步完成：第一步 由编译器在作用域中声明一个变量（前提是之前没有声明过），第二步 是在运行时引擎会在作用域中查找该变量，如果可以找到，就对其赋值。（这里是你所不知道的 JavaScript 原文） 刚才提到，而引擎会对变量 a 进行查找。而这种查找分为两种，一个是 LHS（Left-Hand-Side） 查询，另一个是 RHS（Right-Hand-Side） 查询。 LHS 查询：试图找到变量的容器本身，从而可以对其赋值。也就是查找 变量 a 。 RHS 查询：查找某个变量的值。查找变量 a 的值，即 2。 LHS 和 RHS 的含义是 “赋值操作的左侧或右侧”，并不一定意味着就是 “‘=’ 赋值操作符的坐车或者右侧”。赋值操作还有其他的形式，因此在概念上最好将其理解为 “赋值操作的目标是谁（LHS）” 以及 “赋值操作的源头是谁（RHS）”。 12345// 这个程序中既有 LHS 也有 RHSfunction foo(a) &#123; console.log(a) // 2&#125;foo(2) 事实上，作用域就是根据名称查找变量的一系列规则，实际情况中，通常需要同时顾及几个作用域。 12345678// 对 b 进行的 RHS 引用无法在函数 foo 内部来完成。// 但是可以在上一级作用域（在这个例子里就是全局作用域）中来完成。function foo(a) &#123; console.log(a + b)&#125;var b = 2foo(2) // 4 多个作用域嵌套就会变成作用域链，为了方便理解，我们可以想象如下图这么一个高大的建筑。 这个建筑代表程序中的嵌套的作用域链。第一层楼代表当前的执行作用域，也就是我所处的位置，建筑顶层代表全局作用域。 LHS 和 RHS 应用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦达到顶层（全局作用域），可能找到你所需的变量，也有可能没找到，但无论如何这个查找过程都会停止。 词法作用域简单来说，词法作用域就是定义在词法阶段的作用域。就是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分是情况是这样） 12345678function foo(a) &#123; var b = a * 2 function bar(c) &#123; console.log(a, b, c) &#125; bar(b * 3)&#125;foo(2) // 2, 4, 13 在这个例子中有三个逐级嵌套的作用域，为了方便理解，我们把它想象成三个逐级包含的气泡。 包含着整个全局作用域，其中有一个标识符：foo 。 包含着 foo 所创建的作用域，其中有三个标识符：a 、b 、bar 。 包含着 bar 所创建的作用域，其中有标识符：c 。 在查找变量时，作用域查找会在找到第一个匹配的标识符时停止。而且它只查找一级标识符，比如 a 、b、c，而对于 foo.bar.baz ，词法作用域只会查找 foo 标识符，找到这个变量之后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。 这里还要说一点，全局变量会自动成为全局对象的属性，所以可以间接的通过全局对象属性的引用来对其进行访问。例如：window.a 。 函数作用域JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为自身创建一个作用域，而其他结构都不会创建作用域，但事实上并不完全正确。 123456789101112function foo(a) &#123; var b = 2 ... // 一些代码 function bar() &#123; ... // 一些代码 &#125; ... // 更多的代码 var c = 3&#125;bar() // ReferenceErrorconsole.log(a, b, c) // ReferenceError a、b、c、foo、bar 这些标识符在 foo(..) 的内部都是可以被访问的，同样在 bar(..) 内部也可以被访问。但是这些标识符全部无法从全局作用域中进行访问，所以会导致 ReferenceError 错误。 函数作用域是指，属于这个函数的全部变量都可以在整个函数范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值的“动态”特性。 这样，在任意代码外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 虽然这一技术可以解决一些问题，但是他并不理想。首先，你必须需要声明一个具名函数（foo()），这就意味着这个具名函数本身（foo）“污染”所在作用域。其次，必须显式的通过函数名（foo()）调用这个函数才能运行其中的代码。 JavaScript 提供了解决了这两个问题的方案：123456789var a = 2(function foo()&#123; // &lt;-- 添加这一行 var a = 3 console.log(a) // 3&#125;)() // &lt;-- 以及这一行console.log(a) // 2 由于函数被包含在一对 ( ) 内部，因此成为了一个表达式，通过末尾加上了另外一对 ( ) 可以立刻执行这个函数。这种模式很常见，几年前社区给它规定了一个术语：IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression） 提升变量和函数在内的所有声明都会在任何代码被执行前首先被处理。 123456foo()function foo() &#123; console.log(a) var a = 2&#125; 当你看到 var a = 2 时，可能会认为这是一个声明，但实际上 Javascript 会将其看成两个声明：var a 和 a ＝ 2 ，并且在不同阶段执行。var a 是在编译阶段进行的，而 a = 2 会被留在原地等待执行阶段。 1234567function foo() &#123; var a console.log(a) a = 2&#125;foo(); 这个过程就好像变量和函数声明从它们在代码中出现的位置被 “移动” 到了最上面，这个过程就叫做变量提升。 值得注意有两点： 1. 函数声明会提升，但是函数表达式不会提升。 区分函数声明和函数表达式最简单的方式是看 function 关键字出现在声明中的位置。如果 function 时声明中的第一个词，那么就是函数声明，否则就是一个函数表达式。 12345678910111213141516171819// 函数声明function foo() &#123; var a console.log(a) a = 2&#125;// 函数表达式var foo = function() &#123; var a console.log(a) a = 2&#125;(function foo() &#123; var a console.log(a) a = 2&#125;)() 看一个例子： 1234567foo() // 报TypeError错误var foo = function() &#123; var a console.log(a) a = 2&#125; 上面的代码相当于12345678var foofoo() // 此时 foo 为 undefined，而我们尝试对它进行函数式调用，属于不合理操作，报 TypeError 错误。foo = function() &#123; var a console.log(a) a = 2&#125; 2. 函数会被优先提升，然后是变量。 12345678foo() // 1 var foofunction foo() &#123; console.log(1)&#125;foo = function() &#123; console.log(2)&#125; 会输出 1 而不是 2！！！！ 这段代码会被引擎理解为如下形式： 1234567function foo() &#123; console.log(1)&#125;foo()foo = function() &#123; console.log(2)&#125; 注意：var foo 尽管出现在 function foo()... 的声明之前，但他是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。 尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖掉前面的。 123456789101112foo() // 3, 1被覆盖掉了function foo() &#123; console.log(1)&#125;var foo = function() &#123; console.log(2)&#125;function foo() &#123; console.log(3)&#125; 闭包到底何为闭包呢？先说一下直截了当的定义。 是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量 （《JavaScript 高级程序设计 （第三版）》的定义） 当函数可以记住并访问所在的词法作用域时，就产生了闭包，这个函数持有对该词法作用域的引用，这个引用就叫做闭包 （《你所不知道的 JavaScript》的定义） 可能看定义并不是容易理解，我们来看一段代码； 12345678910function foo() &#123; var a = 2 function bar() &#123; console.log(a) &#125; return bar&#125;var baz = foo()baz() // 2 ———— 这就是闭包的效果 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。 在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz() ，实际上只是通过不同的标识符引用调用了内部的函数 bar() 在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。 而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。 bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 闭包详细例子详见：《你所不知道的 JavaScript》第 5 章节。 之后就需要大量的面试题深入的理解刻在脑袋里了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端触屏事件试验笔记]]></title>
    <url>%2F2017%2F06%2F15%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%A6%E5%B1%8F%E4%BA%8B%E4%BB%B6%E8%AF%95%E9%AA%8C%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[移动端触控事件和 PC 端鼠标事件放在一起究竟能绽放出什么样的火花？（其实就是乱的一遭都是坑随着浏览器变更还会变化… PC 端的鼠标事件PC 网页上的大部分操作都是用鼠标的，即响应的是鼠标事件，包括 mousedown、mouseup、mousemove 和 click 事件。我们只对这四个事件进行监听。一次点击行为，事件的触发过程为：mousedown -&gt; mouseup -&gt; click 三步。 移动端触控事件手机上没有鼠标，所以就用触摸事件去实现类似的功能。touch 事件包含 touchstart、touchmove 和 touchend。我们只对这三个事件进行监听。手指轻触一下（不进行移动操作）事件的过程为：touchstart -&gt; touchend。 在只有这三个事件前提下，这里即使是长按，也不会触发 touchmove 事件，只有按住移动才会触发 touchmove 事件，这个时候事件的触发过程则是 touchstart -&gt; touchmove -&gt; touchend，这里就不贴图了。 移动端也会响应 mouse 事件手机上没有鼠标，但不代表手机不能响应 mouse 事件（其实是借助 touch 去触发 mouse 事件）。 而我们的操作的动作所触发的事件顺序是什么？ 就需要做以下的实验去论证。 我们打开百度首页，F12 打开控制台，点击左上角模拟移动设备，用小屏的 iphone6 进行展示，这个时候，百度首页应该是移动端的界面。 我们在控制台输入以下测试代码 12345678910111213141516171819202122let body = document.querySelector("body")body.addEventListener('touchstart', function()&#123; console.log('touchstart')&#125;, false)body.addEventListener('touchmove', function()&#123; console.log('touchmove')&#125;, false)body.addEventListener('touchend', function()&#123; console.log('touchend')&#125;, false)body.addEventListener('mousemove', function()&#123; console.log('mousemove')&#125;, false)body.addEventListener('mouseup', function()&#123; console.log('mouseup')&#125;, false) body.addEventListener('mousedown', function()&#123; console.log('mousedown')&#125;, false)body.addEventListener('click', function()&#123; console.log('click')&#125;, false) 轻触一次： 响应顺序是 touchstart -&gt; touchend -&gt; mousemove -&gt; mousedown -&gt; mouseup -&gt; click 长触一次： 响应顺序是 touchstart -&gt; mousemove -&gt; touchend 触摸移动时： 响应顺序是 touchstart -&gt; touchmove -&gt; touchend 双击事件： 响应顺序是 touchstart -&gt; touchend -&gt; touchstart -&gt; touchend 移动端 click 事件 300ms 的延迟现象的原因在最早 iphone 的 safari 浏览器中，为了实现触屏中双击放大效果，当用户点击屏幕时后会判断在 300ms 内是否有第二次点击，如果有，就理解成双击，若没有就是单击，就会触发 click 事件。当你点击移动设备的屏幕时，可以分解成多个事件，这些事件是按顺序依次触发的。 如何解决延迟？touchstart、touchend 是没有延迟的，可以在 touchend 时触发用户想要在 click 时触发的事件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中 String 对象的属性及方法]]></title>
    <url>%2F2017%2F06%2F03%2FString%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[既然都整理了 Array ，顺便也把 String 的属性和方法也捋一遍吧。 String 全局对象是一个用于字符串或一个字符序列的构造函数。 属性string.lengthlength 属性表示一个字符串的长度。 12345678var x = "Mozilla";var empty = "";console.log("Mozilla is " + x.length + " code units long");/* "Mozilla is 7 code units long" */console.log("The empty string is has a length of " + empty.length);/* "The empty string is has a length of 0" */ 方法String.fromCharCode()静态 String.fromCharCode() 方法返回使用指定的 Unicode 值序列创建的字符串。 String.fromCharCode(num1, …, numN) 12String.fromCharCode(65,66,67)// 返回 "ABC" String.fromCodePoint()String.fromCodePoint() 静态方法返回使用指定的代码点序列创建的字符串。 String.fromCodePoint(num1[, …[, numN]]) 12345678910111213String.fromCodePoint(42); // "*"String.fromCodePoint(65, 90); // "AZ"String.fromCodePoint(0x404); // "\u0404"String.fromCodePoint(0x2F804); // "\uD87E\uDC04"String.fromCodePoint(194564); // "\uD87E\uDC04"String.fromCodePoint(0x1D306, 0x61, 0x1D307) // "\uD834\uDF06a\uD834\uDF07"String.fromCodePoint('_'); // RangeErrorString.fromCodePoint(Infinity); // RangeErrorString.fromCodePoint(-1); // RangeErrorString.fromCodePoint(3.14); // RangeErrorString.fromCodePoint(3e-2); // RangeErrorString.fromCodePoint(NaN); // RangeError String.prototype.charAt()charAt() 方法从一个字符串中返回指定的字符。 str.charAt(index) 12345678910111213141516// 下例输出字符串 "Brave new world" 不同位置处的字符：var anyString = "Brave new world";console.log("The character at index 0 is '" + anyString.charAt(0) + "'");console.log("The character at index 1 is '" + anyString.charAt(1) + "'");console.log("The character at index 2 is '" + anyString.charAt(2) + "'");console.log("The character at index 3 is '" + anyString.charAt(3) + "'");console.log("The character at index 4 is '" + anyString.charAt(4) + "'");console.log("The character at index 999 is '" + anyString.charAt(999) + "'");// The character at index 0 is 'B'// The character at index 1 is 'r'// The character at index 2 is 'a'// The character at index 3 is 'v'// The character at index 4 is 'e'// The character at index 999 is '' String.prototype.charCodeAt()charCodeAt() 方法返回 0 到 65535 之间的整数，表示给定索引处的 UTF-16 代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元&gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。 str.charCodeAt(index) 1"ABC".charCodeAt(0) // returns 65 String.prototype.codePointAt()codePointAt() 方法返回 一个 Unicode 编码点值的非负整数。 str.codePointAt(pos) 1234'ABC'.codePointAt(1); // 66'\uD800\uDC00'.codePointAt(0); // 65536'XYZ'.codePointAt(42); // undefined String.prototype.concat()concat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 str.concat(string2, string3[, …, stringN]) 123var hello = "Hello, "console.log(hello.concat("Kevin", " have a nice day."))/* Hello, Kevin have a nice day. */ String.prototype.endsWith() 该新特性属于 ECMAScript 2015（ES6）规范，在使用时请注意浏览器兼容性。 endsWith()方法用来判断当前字符串是否是以另外一个给定的子字符串 “结尾” 的，根据判断结果返回 true 或 false。 str.endsWith(searchString [, position]); 123456var str = "To be, or not to be, that is the question.";alert( str.endsWith("question.") ); // truealert( str.endsWith("to be") ); // falsealert( str.endsWith("to be", 19) ); // truealert( str.endsWith("To be", 5) ); // true String.prototype.includes()includes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。 str.includes(searchString[, position]) 1234567var str = 'To be, or not to be, that is the question.';console.log(str.includes('To be')); // trueconsole.log(str.includes('question')); // trueconsole.log(str.includes('nonexistent')); // falseconsole.log(str.includes('To be', 1)); // falseconsole.log(str.includes('TO BE')); // false String.prototype.indexOf()indexOf() 方法返回调用 String 对象中第一次出现的指定值的索引，开始在 fromIndex 进行搜索。如果未找到该值，则返回 -1。 str.indexOf(searchValue[, fromIndex]) 1234567"Blue Whale".indexOf("Blue"); // returns 0"Blue Whale".indexOf("Blute"); // returns -1"Blue Whale".indexOf("Whale", 0); // returns 5"Blue Whale".indexOf("Whale", 5); // returns 5"Blue Whale".indexOf("", 9); // returns 9"Blue Whale".indexOf("", 10); // returns 10"Blue Whale".indexOf("", 11); // returns 10 String.prototype.lastIndexOf()lastIndexOf() 方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从 fromIndex 处开始。 str.lastIndexOf(searchValue[, fromIndex]) 1234"canal".lastIndexOf("a") // returns 3"canal".lastIndexOf("a",2) // returns 1"canal".lastIndexOf("a",0) // returns -1"canal".lastIndexOf("x") // returns -1 String.prototype.link()link() 方法创建一个 \ HTML 元素，用该字符串作为超链接的显示文本，参数作为指向另一个 URL 的超链接。 str.link(url) 12345// 下例显示一个单词 "MDN" 作为超链接，指向 Mozilla Developer Network。var hotText = "MDN";var URL = "https://developer.mozilla.org/";document.write("Click to return to " + hotText.link(URL)); String.prototype.localeCompare()localeCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。新的 locales 、 options 参数能让应用程序定制函数的行为即指定用来排序的语言。 locales 和 options 参数是依赖于具体实现的，在旧的实现中这两个参数是完全被忽略的。 referenceStr.localeCompare(compareString[, locales[, options]]) 1234567891011// The letter "a" is before "c" yielding a negative value'a'.localeCompare('c'); // -2 or -1 (or some other negative value)// Alphabetically the word "check" comes after "against" yielding a positive value'check'.localeCompare('against'); // 2 or 1 (or some other positive value)// "a" and "a" are equivalent yielding a neutral value of zero'a'.localeCompare('a'); // 0 String.prototype.match()当一个字符串与一个正则表达式匹配时， match() 方法检索匹配项。 str.match(regexp); 1234567891011121314151617var str = 'For more information, see Chapter 3.4.5.1';var re = /see (chapter \d+(\.\d)*)/i;var found = str.match(re);console.log(found);// logs [ 'see Chapter 3.4.5.1',// 'Chapter 3.4.5.1',// '.1',// index: 22,// input: 'For more information, see Chapter 3.4.5.1' ]// 'see Chapter 3.4.5.1' 是整个匹配。// 'Chapter 3.4.5.1' 被'(chapter \d+(\.\d)*)'捕获。// '.1' 是被'(\.\d)'捕获的最后一个值。// 'index' 属性(22) 是整个匹配从零开始的索引。// 'input' 属性是被解析的原始字符串。 String.prototype.normalize() 该新特性属于 ECMAScript 2015（ES6）规范，在使用时请注意浏览器兼容性。 normalize() 方法会按照指定的一种 Unicode 正规形式将当前字符串正规化. str.normalize([form]); 1234567891011121314151617181920212223242526272829303132333435// Initial string// U+1E9B: LATIN SMALL LETTER LONG S WITH DOT ABOVE// U+0323: COMBINING DOT BELOWvar str = "\u1E9B\u0323";// Canonically-composed form (NFC)// U+1E9B: LATIN SMALL LETTER LONG S WITH DOT ABOVE// U+0323: COMBINING DOT BELOWstr.normalize("NFC"); // "\u1E9B\u0323"str.normalize(); // same as above// Canonically-decomposed form (NFD)// U+017F: LATIN SMALL LETTER LONG S// U+0323: COMBINING DOT BELOW// U+0307: COMBINING DOT ABOVEstr.normalize("NFD"); // "\u017F\u0323\u0307"// Compatibly-composed (NFKC)// U+1E69: LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVEstr.normalize("NFKC"); // "\u1E69"// Compatibly-decomposed (NFKD)// U+0073: LATIN SMALL LETTER S// U+0323: COMBINING DOT BELOW// U+0307: COMBINING DOT ABOVEstr.normalize("NFKD"); // "\u0073\u0323\u0307" String.prototype.repeat()repeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。 let resultString = str.repeat(count); 123456789"abc".repeat(-1) // RangeError: repeat count must be positive and less than inifinity"abc".repeat(0) // """abc".repeat(1) // "abc""abc".repeat(2) // "abcabc""abc".repeat(3.5) // "abcabcabc" 参数count将会被自动转换成整数."abc".repeat(1/0) // RangeError: repeat count must be positive and less than inifinity(&#123;toString : () =&gt; "abc", repeat : String.prototype.repeat&#125;).repeat(2) //"abcabc",repeat是一个通用方法,也就是它的调用者可以不是一个字符串对象. String.prototype.replace()replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者是一个每次匹配都需要调用的函数。 str.replace(regexp|substr, newSubstr|function) 12345function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(' - ');&#125;var newString = 'abc12345#$*%'.replace(/([^\d]*)(\d*)([^\w]*)/, replacer); String.prototype.search()search() 方法执行正则表达式和 String对象之间的一个搜索匹配。 str.search(regexp) 123456789function testinput(re, str)&#123; var midstring; if (str.search(re) != -1)&#123; midstring = " contains "; &#125; else &#123; midstring = " does not contain "; &#125; console.log (str + midstring + re);&#125; String.prototype.slice()slice() 方法提取一个字符串的一部分，并返回一新的字符串。 str.slice(beginSlice[, endSlice]) 12345var str1 = 'The morning is upon us.';var str2 = str1.slice(4, -2);console.log(str2); // OUTPUT: morning is upon u String.prototype.split()split() 方法将一个String对象分割成字符串数组，通过将字符串分成子串。 str.split([separator[, limit]]) 12"Webkit Moz O ms Khtml".split( " " ) // ["Webkit", "Moz", "O", "ms", "Khtml"] String.prototype.startsWith() 该新特性属于 ECMAScript 2015（ES6）规范，在使用时请注意浏览器兼容性。 startsWith() 方法用来判断当前字符串是否是以另外一个给定的子字符串 “开头” 的，根据判断结果返回 true 或 false。 str.startsWith(searchString [, position]); 12345var str = "To be, or not to be, that is the question.";alert(str.startsWith("To be")); // truealert(str.startsWith("not to be")); // falsealert(str.startsWith("not to be", 10)); // true String.prototype.substr()substr() 方法返回一个字符串中从指定位置开始到指定字符数的字符。 str.substr(start[, length]) 12345678var str = "abcdefghij";console.log("(1,2): " + str.substr(1,2)); // (1,2): bcconsole.log("(-3,2): " + str.substr(-3,2)); // (-3,2): hiconsole.log("(-3): " + str.substr(-3)); // (-3): hijconsole.log("(1): " + str.substr(1)); // (1): bcdefghijconsole.log("(-20, 2): " + str.substr(-20,2)); // (-20, 2): abconsole.log("(20, 2): " + str.substr(20,2)); // (20, 2): String.prototype.substring()substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。 str.substring(indexStart[, indexEnd]) 1234567891011121314151617181920212223var anyString = "Mozilla";// 输出 "Moz"console.log(anyString.substring(0,3));console.log(anyString.substring(3,0));console.log(anyString.substring(3,-3));console.log(anyString.substring(3,NaN));console.log(anyString.substring(-2,3));console.log(anyString.substring(NaN,3));// 输出 "lla"console.log(anyString.substring(4,7));console.log(anyString.substring(7,4));// 输出 ""console.log(anyString.substring(4,4));// 输出 "Mozill"console.log(anyString.substring(0,6));// 输出 "Mozilla"console.log(anyString.substring(0,7));console.log(anyString.substring(0,10)); String.prototype.toLocaleLowerCase()toLocaleLowerCase() 方法根据任何特定于语言环境的案例映射，返回调用字符串值转换为小写的值。 str.toLocaleLowerCase() 12345console.log('ALPHABET'.toLocaleLowerCase()); // 'alphabet'console.log('中文简体 zh-CN || zh-Hans'.toLocaleLowerCase());// '中文简体 zh-cn || zh-hans' String.prototype.toLocaleUpperCase()toLocaleUpperCase() 使用本地化（locale-specific）的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串。 str.toLocaleUpperCase() 12console.log('alphabet'.toLocaleUpperCase()); // 'ALPHABET' String.prototype.toLowerCase()toLowerCase() 会将调用该方法的字符串值转为小写形式，并返回。 str.toLowerCase() 12345console.log('中文简体 zh-CN || zh-Hans'.toLowerCase());// 中文简体 zh-cn || zh-hans​console.log( "ALPHABET".toLowerCase() ); // "alphabet" String.prototype.toString()toString() 方法返回指定对象的字符串形式。 str.toString() 123var x = new String("Hello world");alert(x.toString()) // 输出 "Hello world" String.prototype.toUpperCase()toUpperCase() 将调用该方法的字符串值转换为大写形式，并返回。 str.toUpperCase() 12​console.log( "alphabet".toUpperCase() );// "ALPHABET" String.prototype.trim()trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。 str.trim() 1234567var orig = ' foo ';console.log(orig.trim()); // 'foo'// 另一个.trim()例子，只从一边删除var orig = 'foo ';console.log(orig.trim()); // 'foo' String.prototype.valueOf()valueOf() 方法返回一个 String 对象的原始值（primitive value）。 str.valueOf() 123x = new String("Hello world");alert(x.valueOf()) // Displays "Hello world"]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中 Array 对象的属性及方法]]></title>
    <url>%2F2017%2F06%2F01%2FArray%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[没想到刷了 lodash 之后，这些属性和方法居然还能忘差不多，面试手写代码的时候心哇哇凉，今天 总结 + 手打 + 朗读 增加记忆。列在博客里面也方便复习，省着下次面试悲剧。 JavaScript 数组对象是一个用于构造数组的全局对象。 如何创建一个数组？12let arr = []let arr2 = new Array() 属性Array.lengthlength 属性表示一个无符号 32-bit 整数，返回一个数组中的元素个数。 12var items = ["shoes", "shirts", "socks", "sweaters"]items.length // 返回 4 方法Array.from()Array.from() 方法从一个类似数组或可迭代的对象中创建一个新的数组实例。 Array.from(arrayLike[, mapFn[, thisArg]]) 123456const bar = ["a", "b", "c"];Array.from(bar);// ["a", "b", "c"]Array.from('foo');// ["f", "o", "o"] Array.isArray()Array.isArray() 用于确定传递的值是否是一个 Array。 Array.isArray(obj) 12345678Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray("foobar"); // falseArray.isArray(undefined); // false Array.of()Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。 Array.of(element0[, element1[, …[, elementN]]]) 12345Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7); // [ , , , , , , ]Array(1, 2, 3); // [1, 2, 3] Array.prototype.concat()concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 var new_array = old_array.concat(value1[, value2[, …[, valueN]]]) 1234567891011121314let arr1 = ["a", "b", "c"];let arr2 = ["d", "e", "f"];let arr3 = arr1.concat(arr2);console.log(arr3);// results in a new array // [ "a", "b", "c", "d", "e", "f" ]console.log(arr1);// ["a", "b", "c"]console.log(arr2);// ["d", "e", "f"] Array.prototype.copyWithin()copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。 arr.copyWithin(target)arr.copyWithin(target, start)arr.copyWithin(target, start, end)arr.copyWithin(目标索引, [源开始索引], [结束源索引]) 1234567891011121314["alpha", "beta", "copy", "delta"].copyWithin(1, 2, 3);// 0:"alpha" 1:"beta" 2:"copy" 3:"delta"// ["alpha", "copy", "copy", "delta"]// 0:"alpha" 1:"copy" 2:"copy" 3:"delta"// target === 1:"beta"// start === 2:"copy", // end === 3:"delta"// 1:"beta" =&gt; 1:"copy"['alpha', 'bravo', 'charlie', 'delta'].copyWithin(2, 0);// results in ["alpha", "bravo", "alpha", "bravo"] Array.prototype.every()every() 方法测试数组的所有元素是否都通过了指定函数的测试。 arr.every(callback[, thisArg]) 12345678//下例检测数组中的所有元素是否都大于 10。function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true Array.prototype.fill()fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。 arr.fill(value)arr.fill(value, start)arr.fill(value, start, end) 1234var numbers = [1, 2, 3]numbers.fill(1);// results in [1, 1, 1] Array.prototype.filter()filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 var new_array = arr.filter(callback[, thisArg]) 1234567891011121314151617function isBigEnough(value) &#123; return value &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44]// ES6 wayconst isBigEnough = value =&gt; value &gt;= 10;let [...spraed]= [12, 5, 8, 130, 44];let filtered = spraed.filter(isBigEnough);// filtered is [12, 130, 44] Array.prototype.find()find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 arr.find(callback[, thisArg]) 12345function isBigEnough(element) &#123; return element &gt;= 15;&#125;[12, 5, 8, 130, 44].find(isBigEnough); // 130 Array.prototype.findIndex()findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回 -1。 arr.findIndex(callback[, thisArg]) 12345function isBigEnough(element) &#123; return element &gt;= 15;&#125;[12, 5, 8, 130, 44].findIndex(isBigEnough); // 3 Array.prototype.forEach()forEach() 方法对数组的每个元素执行一次提供的函数。 array.forEach(callback(currentValue, index, array) { // do something}, this)array.forEach(callback[, thisArg]) 123456789let a = ['a', 'b', 'c'];a.forEach(function(element) &#123; console.log(element);&#125;);// a// b// c Array.prototype.includes()includes() 方法用来判断一个数组是否包含一个指定的值，如果是，酌情返回 true 或 false。 arr.includes(searchElement)arr.includes(searchElement, fromIndex) 1234567let a = [1, 2, 3];a.includes(2); // true a.includes(4); // false Array.prototype.indexOf()indexOf() 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回 -1。 arr.indexOf(searchElement)arr.indexOf(searchElement[, fromIndex = 0]) 12345678910let a = [2, 9, 7, 8, 9]; a.indexOf(2); // 0 a.indexOf(6); // -1a.indexOf(7); // 2a.indexOf(8); // 3a.indexOf(9); // 1if (a.indexOf(3) === -1) &#123; // element doesn't exist in array&#125; Array.prototype.join()join() 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。 str = arr.join()// 默认为 “,”str = arr.join(“”)// 分隔符 === 空字符串 “”str = arr.join(separator)// 分隔符 12345678910111213141516let a = ['Wind', 'Rain', 'Fire'];a.join(); // 默认为 ","// 'Wind,Rain,Fire'a.join(""); // 分隔符 === 空字符串 ""// "WindRainFire"a.join("-"); // 分隔符 "-"// 'Wind-Rain-Fire'console.log(a);// ['Wind', 'Rain', 'Fire'] Array.prototype.keys()keys() 方法返回一个新的 Array 迭代器，它包含数组中每个索引的键。 arr.keys() 12345678910111213141516171819let arr = ["a", "b", "c"];let iterator = arr.keys();// undefinedconsole.log(iterator);// Array Iterator &#123;&#125;console.log(iterator.next()); // Object &#123;value: 0, done: false&#125;console.log(iterator.next()); // Object &#123;value: 1, done: false&#125;console.log(iterator.next()); // Object &#123;value: 2, done: false&#125;console.log(iterator.next()); // Object &#123;value: undefined, done: true&#125; Array.prototype.lastIndexOf()lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1]) 1234567891011121314// 下例使用 lastIndexOf 定位数组中的值。var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);// index is 3index = array.lastIndexOf(7);// index is -1index = array.lastIndexOf(2, 3);// index is 3index = array.lastIndexOf(2, 2);// index is 0index = array.lastIndexOf(2, -2);// index is 0index = array.lastIndexOf(2, -1);// index is 3 Array.prototype.map()map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 let array = arr.map(function callback(currentValue, index, array) { // Return element for new_array}[, thisArg]) 1234567891011121314151617181920212223242526272829// 使用三个参数const numbers = [1, 2, 3, 4, 5];let arr = numbers.map((currentValue, index, array) =&gt; &#123; console.log(`currentValue = `, currentValue); console.log(`index = `, index); console.log(`array= `, array); return currentValue * 2;&#125;, numbers);console.log(`arr `, arr);let numbers = [1, 5, 10, 15];let doubles = numbers.map((x) =&gt; &#123; return x * 2;&#125;);// doubles is now [2, 10, 20, 30]// numbers is still [1, 5, 10, 15]let numbers = [1, 4, 9];let roots = numbers.map(Math.sqrt);// roots is now [1, 2, 3]// numbers is still [1, 4, 9] Array.prototype.pop()pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 arr.pop() 1234567let a = [1, 2, 3];a.length; // 3a.pop(); // 3console.log(a); // [1, 2]a.length; // 2 Array.prototype.push()push() 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度。 arr.push(element1, …, elementN) 12345678910var numbers = [1, 2, 3];numbers.push(4);console.log(numbers); // [1, 2, 3, 4]numbers.push(5, 6, 7);console.log(numbers); // [1, 2, 3, 4, 5, 6, 7] Array.prototype.reduce()reduce() 方法对累加器和数组中的每个元素 (从左到右) 应用一个函数，将其减少为单个值。 array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue) 123456789var total = [0, 1, 2, 3].reduce(function(sum, value) &#123; return sum + value;&#125;, 0);// total is 6var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123; return a.concat(b);&#125;, []);// flattened is [0, 1, 2, 3, 4, 5] Array.prototype.reduceRight()reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。 arr.reduceRight(callback[, initialValue]) 123456789let flattened = [ [0, 1], [2, 3], [4, 5]].reduceRight((a, b) =&gt; &#123; return a.concat(b);&#125;, []);// flattened is [4, 5, 2, 3, 0, 1] Array.prototype.reverse()reverse() 方法将数组中元素的位置颠倒。第一个数组元素成为最后一个数组元素，最后一个数组元素成为第一个。 arr.reverse() 1234var myArray = ['one', 'two', 'three'];myArray.reverse(); console.log(myArray) // ['three', 'two', 'one'] Array.prototype.shift()shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 arr.shift() 12345678let a = [1, 2, 3];let b = a.shift();console.log(a); // [2, 3]console.log(b); // 1 Array.prototype.slice()slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。 arr.slice()arr.slice(begin)arr.slice(begin, end) 12345678let a = ['zero', 'one', 'two', 'three'];let sliced = a.slice(1, 3);console.log(a); // [ 'zero', 'one', 'two', 'three' ]console.log(sliced); // [ 'one', 'two' ] Array.prototype.some()some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试。 arr.some(callback[, thisArg]) 123456789const isBiggerThan10 = (element, index, array) =&gt; &#123; return element &gt; 10;&#125;[2, 5, 8, 1, 4].some(isBiggerThan10); // false[12, 5, 8, 1, 4].some(isBiggerThan10); // true Array.prototype.sort()sort() 方法在适当的位置对数组的元素进行排序，并返回数组。 sort 排序不一定是稳定的。默认排序顺序是根据字符串 Unicode 码点。 arr.sort()arr.sort(compareFunction) 123456789101112131415var fruit = ['cherries', 'apples', 'bananas'];fruit.sort(); // ['apples', 'bananas', 'cherries']var scores = [1, 10, 21, 2]; scores.sort(); // [1, 10, 2, 21]// 注意10在2之前,// because '10' comes before '2' in Unicode code point order.var things = ['word', 'Word', '1 Word', '2 Words'];things.sort(); // ['1 Word', '2 Words', 'Word', 'word']// 在Unicode中, 数字在大写字母之前,// 大写字母在小写字母之前. Array.prototype.splice()splice() 方法通过删除现有元素和 / 或添加新元素来更改一个数组的内容。 array.splice(start)array.splice(start, deleteCount)array.splice(start, deleteCount, item1, item2, …) 1234567891011121314151617181920212223242526var myFish = ["angel", "clown", "mandarin", "surgeon"];//从第 2 位开始删除 0 个元素，插入 "drum"var removed = myFish.splice(2, 0, "drum");//运算后的 myFish:["angel", "clown", "drum", "mandarin", "surgeon"]//被删除元素数组：[]，没有元素被删除//从第 3 位开始删除 1 个元素removed = myFish.splice(3, 1);//运算后的myFish：["angel", "clown", "drum", "surgeon"]//被删除元素数组：["mandarin"]//从第 2 位开始删除 1 个元素，然后插入 "trumpet"removed = myFish.splice(2, 1, "trumpet");//运算后的myFish: ["angel", "clown", "trumpet", "surgeon"]//被删除元素数组：["drum"]//从第 0 位开始删除 2 个元素，然后插入 "parrot", "anemone" 和 "blue"removed = myFish.splice(0, 2, "parrot", "anemone", "blue");//运算后的myFish：["parrot", "anemone", "blue", "trumpet", "surgeon"]//被删除元素的数组：["angel", "clown"]//从第 3 位开始删除 2 个元素removed = myFish.splice(3, Number.MAX_VALUE);//运算后的myFish: ["parrot", "anemone", "blue"]//被删除元素的数组：["trumpet", "surgeon"] Array.prototype.toLocaleString()toLocaleString() 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 “,”）隔开。 arr.toLocaleString(); 123456789var number = 1337;var date = new Date();var myArr = [number, date, "foo"];var str = myArr.toLocaleString(); console.log(str); // 输出 "1337,2015/2/27 下午8:29:04,foo" // 假定运行在中文（zh-CN）环境，北京时区 Array.prototype.toString()toString() 返回一个字符串，表示指定的数组及其元素。 arr.toString() 12var monthNames = ['Jan', 'Feb', 'Mar', 'Apr'];var myVar = monthNames.toString(); // assigns "Jan,Feb,Mar,Apr" to myVar. Array.prototype.unshift()unshift() 方法将一个或多个元素添加到数组的开头，并返回新数组的长度。 12345let a = [1, 2, 3];a.unshift(4, 5);console.log(a);// [4, 5, 1, 2, 3]]]></content>
  </entry>
  <entry>
    <title><![CDATA[web前端开发面试知识点整理]]></title>
    <url>%2F2017%2F05%2F26%2Fweb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[JavaScript原型 我们创建的每一个函数，都可以有一个 prototype 属性，该属性指向一个对象。这个对象，就是原型。 当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过 prototype 属性，挂载在原型对象上。而每一个 new 出来的实例，都有一个 proto 属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过 proto 访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。 1234567891011121314// 声明构造函数function Person(name, age) &#123; this.name = name; this.age = age;&#125; // 通过prototye属性，将方法挂载到原型对象上Person.prototype.getName = function() &#123; return this.name;&#125; var p1 = new Person('tim', 10);var p2 = new Person('jak', 22);console.log(p1.getName === p2.getName); // true 通过图示我们可以看出，构造函数的 prototype 与所有实例对象的 proto 都指向原型对象。而原型对象的 constructor 指向构造函数。 原型链 基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法（红宝书） 我们知道所有的函数都有一个叫做 toString 的方法。那么这个方法到底是在哪里的呢？ 先随意声明一个函数： 1function foo() &#123;&#125; 其中 foo 是 Function 对象的实例。而 Function 的原型对象同时又是 Object 的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是 foo 最终能够访问到处于 Object 原型对象上的 toString 方法的原因。 作用域链作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 window 对象即被终止，作用域链向下访问变量是不被允许的。 闭包 第一种理解（红宝书）：是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量 第二种理解（你不知道的 javascript）：当函数可以记住并访问所在的词法作用域时，就产生了闭包，这个函数持有对该词法作用域的引用，这个引用就叫做闭包 闭包本质还是函数，只不过这个函数绑定了上下文环境（函数内部引用的所有变量） 缺点： 常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 作用（使用场景）： 可以用来管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作。 闭包有三个特性： 函数嵌套函数 函数内部可以应用外部的参数和变量 参数和变量不会被垃圾回收机制回收 题外话： Javascript 的作用域是词法作用域而不是动态作用域 词法作用域最重要的特征是它的定义过程发生在代码的书写阶段 动态作用域的作用域链是基于调用栈的 词法作用域的作用域链是基于代码中的作用域嵌套 this 相关this 的指向： 作为普通函数调用（this 指向全局对象 window 对象） 作为对象的方法调用（this 指向该对象） 构造器调用（this 指向用 new 返回的这个对象） call、apply、bind 的调用（this 指向第一个参数对象） 高阶函数 函数作为参考数值 函数作为返回值输出 new 操作符具体干了些什么呢？ 创建一个新对象 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 如何判断一个变量是数组(或者其他) Array.isArray arr instanceof Array arr.proto === Array.prototype arr.constructor === Array Object.prototype.toString.call(arr) === ‘[object Array]’ lodash中 _.isArray 继承简单原型链继承 1234567function Super()&#123; this.name = 'hzzly';&#125;function Sub()&#123; // ...&#125;Sub.prototype = new Super(); // 核心 缺点：修改 sub1.name 后 sub2.name 也变了，因为来自原型对象的引用属性是所有实例共享的。 构造函数式继承 12345678910function Super(val)&#123; this.val = val; his.fun = function()&#123; // 实例函数 // ... &#125;&#125;function Sub(val)&#123; Super.call(this, val); // 核心 // ...&#125; 缺点：无法实现函数复用，每个子类实例都持有一个新的 fun 函数，太多了就会影响性能，内存爆炸。 组合式继承 123456789101112function Super()&#123; this.name = 'hzzly';&#125;// 原型函数Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;Sub.prototype = new Super(); // 核心 缺点： 子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上父类的。又是内存浪费。 寄生组合式继承 123456789101112function Super()&#123; this.name = 'hzzly';&#125;Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;Sub.prototype=Object.create(Super.prototype) // 核心Sub.prototype.constructor=Sub // 核心 es6 的 class 继承方式 1234class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true es6 引入了 class、extends、super、static(部分为 ES2016 标准) null 和 undefined 的区别 null 是一个表示” 无” 的对象，转为数值时为 0；undefined 是一个表示” 无” 的原始值，转为数值时为 NaN。 undefined 表示” 缺少值”，就是此处应该有一个值，但是还没有定义。 null 表示” 没有对象”，即该处不应该有值。 call、apply、bind 的区别 三者都是用来改变函数的 this 对象的指向的。 三者第一个参数都是 this 要指向的对象，也就是指定的上下文。 call 传入的参数数量不固定，第二部分参数要一个一个传， 用 , 隔开。 apply 接受 2 个参数，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。 bind 是返回一个改变了上下文的函数副本，便于稍后调用；apply、call 则是立即调用。 简述面向对象的三大特性 封装：每个对象都包括自己进行操作所需要的所有信息，而不依赖于其他对象来完成自己的操作。这样的方法和属性通过类的实例来实现。 继承：继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 多态：所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。 浏览器机制、性能优化本地存储 sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 cookie 和 session cookie 数据存放在客户的浏览器上，session 数据放在服务器上。 cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。 session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie。 单个 cookie 保存的数据不能超过 4k，很多浏览器都限制一个站点最多保存 20 个 cookie。每次请求一个新的页面的时候 cookie 都会被发送过去，与服务器进行交互。 XML 和 JSON 的区别？ 数据体积方面。 JSON 相比于 XML 来讲，数据的体积小，传递的速度更快些。 数据交互方面。 JSON 与 JavaScript 的交互效果更加方便，更好的数据交互。 数据描述方面。 JSON 对数据的描述比 XML 较差。 传输速度方面。 JSON 的速度要远快于 XML。 如何实现浏览器内多个标签页之间的通信？调用 localstorage、cookie 等本地存储方式 线程和进程的区别？ 一个程序至少有一个进程，一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的，每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立运行，必须依存在应用程序中，由应用程序提供多个线程进行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是操作系统并没有将多个线程看作多个独立的应用，来实现进程的调度管理以及资源分配。这就是进程和线程的重要区别。 渐进增强和优雅降级 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能没然后在针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级： 一开始就构建完整的功能，然后在对低版本浏览器进行兼容。 性能优化 网页内容 减少 http 请求次数 减少 DNS 查询次数 避免页面跳转 缓存 Ajax 延迟加载 提前加载 减少 DOM 元素数量 避免 404 服务器 使 CDN（内容分发网络） 添加 Expires 和 Cache-Control 报文头 Gzip 压缩传输文件 CSS 将样式表置项 避免使用 @import JavaScript 把脚本置于页面底部 使用外部 JavaScript 和 CSS 精简 JavaScript 和 CSS 去除重复脚本 减少 DOM 访问 图片 优化图像 优化 CSS Spirite 不要在 HTML 中缩放图片 favicon.ico 要小且可缓存 如何解决跨域问题？ jsonp、CORS、document.domain+iframe、window.name、window.postMessage jsonp 的原理是动态插入 script 标签 请解释一下 JavaScript 的同源策略。 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 哪些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） JavaScript 垃圾回收机制 标记清除：这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为 “进入环境”，当变量离开环境的时候（函数执行结束）将其标记为 “离开环境”。 引用计数：引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间。 事件、IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？事件处理机制：IE 是事件冒泡、firefox 同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。 阻止冒泡：ev.stopPropagation() 严格模式的限制和设立严格模式的目的 严格模式是 JavaScript 中的一种限制性更强的变种方式。严格模式会将 JavaScript 陷阱直接变成明显的错误。同样的代码有些时候严格模式会比非严格模式下更快。禁用了一些有可能在未来版本中定义的语法。 要给某个函数开启严格模式，得把 “use strict” 声明一字不漏地放在函数体所有语句之前。 限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 禁止 this 指向全局对象 不能使用 with 语句 增加了保留字 arguments 不会自动反映函数参数的变化 目的： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为；消除代码运行的一些不安全之处，保证代码运行的安全；提高编译器效率，增加运行速度；为未来新版本的 Javascript 做好铺垫。 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。使用事件代理的好处是可以提高性能。 Event Loop、消息队列、事件轮询异步函数在执行结束后，会在事件队列中添加一个事件（回调函数）(遵循先进先出原则)，主线程中的代码执行完毕后（即一次循环结束），下一次循环开始就在事件队列中 “读取” 事件，然后调用它所对应的回调函数。这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环） 主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码（同步任务）调用各种外部 API，它们在” 任务队列” 中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取” 任务队列”，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取” 任务队列”（异步任务）之前执行。 缓存 浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据， http 缓存 http 缓存是基于 HTTP 协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件 判断 expires，如果未过期，直接读取 http 缓存文件 index DB 是一个在客户端存储可观数量的结构化数据, 并且为这些数据添加索引进行高性能检索。 cookie 指一般网站为了辨别用户身份、储存在用户本地终端上的数据（通常经过加密）。cookie 一般通过 http 请求中在头部一起发送到服务器端。一条 cookie 记录主要由键、值、域、过期时间、大小组成，一般用户保存用户的认证信息。 localstorage localStorage 是 h5 的一种新的本地缓存方案, 加快下次页面打开时的渲染速度, 除非主动删除数据，否则数据是永远不会过期的。 sessionstorage 也是 h5 的一种本地缓存方案，数据的存储仅特定于某个会话中，也就是说数据只保持到浏览器关闭，当浏览器关闭后重新打开这个页面时， 之前的存储已经被清除。 关于 ES6ES6 的了解es6 是一个新的标准，它包含了许多新的语言特性和库，是 JS 最实质性的一次升级。比如’箭头函数’、’字符串模板’、’generators(生成器)’、’async/await’、’解构赋值’、’class’等等，还有就是引入 module 模块的概念。 箭头函数 可以让 this 指向固定化，这种特性很有利于封装回调函数 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 async/await 是写异步代码的新方式，以前的方法有回调函数和 Promise。 async/await 是基于 Promise 实现的，它不能用于普通的回调函数。 async/await 与 Promise 一样，是非阻塞的。 async/await 使得异步代码看起来像同步代码，这正是它的魔力所在。 请列出尽量多的es6的新语法。 反引号 12var str = `abc $&#123;expr + `abc`&#125;`fn`abcdef$&#123;x&#125;$&#123;y&#125;` 箭头函数 1234var fn = () =&gt; &#123;&#125;var fn = _ =&gt; 2var that = thisvar fn = _ =&gt; (this === that) 解构赋值 123456789var a = 1var b = 2var [c, d] = [a, b]var &#123;a, b&#125; = &#123;a: 1,b: 2,c: 3&#125; 形参解构 12345678910111213function a(&#123;x, y&#125;)&#123;console.log(x * y)&#125;a(&#123;x:1,y:8,&#125;)function b([x, y])&#123;&#125;b([1, 2, 3, 4, 5]) 计算属性 1234567891011121314var obj = &#123; a: 8,&#125;obj[x*y] = 9var obj = &#123; [expr]: 3, expr: 5, get [a]() &#123; &#125;, set [](value) &#123; &#125;,&#125; restpara 剩余参数 123function(a, b, c, ...args)&#123;&#125; spread operator 数组展开 1Math.max(...[1,2,3,4,5,6,7,8,9]) === Math.max(1,2,3,4,5,6,7,8,9) let 用let声明的变量不提升，TDZ， temaper Dead Zone 12345678&#123; var a = 8 ... ... ... let b =9 console.log(a * b)&#125; 默认参数 1function f(x = 8, y = 9, z = function()&#123;&#125;) const 阻止被const声明变量指向其他的值 12const a = expra = xxx //报错 class 12345678910111213141516171819class A &#123; //静态方法 //挂在A上 //即A.f static f()&#123; return 8 &#125; //构造函数体 //即function A()&#123;&#125; constructor() &#123; this.x = 9 this.fn = function()&#123;&#125; &#125; //实例方法 //即A.prototype.methodA methodA()&#123; &#125;&#125; forof 对象方法简写/对象属性简写 Map/Set Symbol Proxy gennerator 说说你对 Promise 的理解 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听——更合理和更强大。 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 对象有以下两个特点: 对象的状态不受外界影响，Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 说说你对 AMD 和 Commonjs 的理解CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。 AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的。 Gulp、Webpack 比较 Gulp Gulp 就是为了规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与压缩、mock 数据等功能的一个前端自动化构建工具。 Gulp 就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理。 Gulp 是通过 task 对整个开发过程进行构建。 Webpack 当下最热门的前端资源模块化管理和打包工具 可以很好的管理模块以及各个模块之间的依赖 对 js、css、图片等资源文件都支持打包 有独立的配置文件 webpack.config.js 可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间 可以生成优化且合并后的静态资源 Webpack两大特色： 代码可以自动完成编译。 loader 可以处理各种类型的静态文件，并且支持串联操作 CSSdisplay:none 和 visibility:hidden 的区别？display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 position:absolute 和 float 属性的异同 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 不同点：float 仍会占据位置，position 会覆盖文档流中的其他元素。 box-sizing 属性 content-box：让元素维持 W3C 的标准盒模型。元素的宽度 / 高度由 border + padding + content 的宽度 / 高度决定，设置 width/height 属性指的是 content 部分的宽 / 高，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 border-box：让元素维持 IE 传统盒模型（IE6 以下版本和 IE6~7 的怪异模式）。设置 width/height 属性指的是 border + padding + content position 的值 static 默认值。没有定位，元素出现在正常的流中 relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 absolute 生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed （老 IE 不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。 CSS3 新特性 CSS3 实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转, 缩放, 定位, 倾斜 增加了更多的 CSS 选择器 多背景 rgba 在 CSS3 中唯一引入的伪元素是::selection. 媒体查询，多栏布局 border-image CSS spritesCSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的 “background-image”，“background- repeat”，“background-position” 的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是 6 个。对于未来而言，就不需要这样做了，因为有了 http2。 解释下浮动和它的工作原理？清除浮动的技巧浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 使用空标签清除浮动。这种方法是在所有浮动标签后面添加一个空标签 定义 css clear:both. 弊端就是增加了无意义标签。 使用 overflow。设置 overflow 为 hidden 或者 auto，给包含浮动元素的父标签添加 css 属性 overflow:auto; zoom:1; zoom:1 用于兼容 IE6。 使用 after 伪对象清除浮动。该方法只适用于非 IE 浏览器。该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；1234567#box:after&#123; content:"."; height:0; visibility:hidden; display:block; clear:both;&#125; 浮动元素引起的问题 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素（内联元素）会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 HTML说说你对语义化的理解 去掉或者丢失样式的时候能够让页面呈现出清晰的结构 有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。 Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义? &lt;!DOCTYPE&gt; 告知浏览器的解析器用什么文档标准解析这个文档。 严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 &lt;!DOCTYPE&gt; 不存在或格式不正确会导致文档以混杂模式呈现。 你知道多少种 Doctype 文档类型？该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 HTML 与 XHTML——二者有什么区别 所有的标记都必须要有一个相应的结束标记 所有标签的元素和属性的名字都必须使用小写 所有的 XML 标记都必须合理嵌套 所有的属性必须用引号”” 括起来 把所有 &lt; 和 &amp; 特殊符号用编码表示 给所有属性赋一个值 不要在注释内容中使 “–” 图片必须有说明文字 html5 有哪些新特性 语义化更好的内容标签（header,nav,footer,aside,article,section） 音频、视频 API(audio,video) 画布 (Canvas) API 地理 (Geolocation) API 拖拽释放 (Drag and drop) API 本地离线存储 表单控件，calendar、date、time、email、url、search 计算机网络HTTP 请求类型 GET：向特定的资源发出请求 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的创建和 / 或已有资源的修改 PUT：向指定资源位置上传其最新内容 DELETE：请求服务器删除 Request-URI 所标识的资源 OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送’*’的请求来测试服务器的性能。 HTTP 请求四部分 HTTP 请求的方法或动作，比如是 get 还是 post 请求； 正在请求的 URL（请求的地址）； 请求头，包含一些客户端环境信息、身份验证信息等； 请求体（请求正文），可以包含客户提交的查询字符串信息、表单信息等。 请求头字段： Accept:text/html,image/*(告诉服务器，浏览器可以接受文本，网页图片) Accept-Charaset:ISO-8859-1 [接受字符编码：iso-8859-1] Accept-Encoding:gzip,compress[可以接受 gzip,compress 压缩后数据] Accept-Language:zh-cn[浏览器支持的语言] Host:localhost:8080[浏览器要找的主机] If-Modified-Since:Tue, 09 May 2017 01:34:02 GMT[告诉服务器我这缓存中有这个文件, 该文件的时间是…] User-Agent:Nozilla/4.0(Com…)[告诉服务器我的浏览器内核，客户端环境信] Cookie：[身份验证信息] Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接] HTTP 响应三部分 一个数字和文字组成的状态码，用来显示请求是成功还是失败； 响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等； 响应体（响应正文）。 响应头字段： Cache-Control:[告诉浏览器如何缓存页面 (因为浏览器的兼容性最好设置两个)] Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接] Content-Type:text/html;charset=gb2312[内容格式和编码] Last-Modified:Tue,11 Juj,2017 18 18:29:20[告诉浏览器该资源上次更新时间是多少] ETag:”540-54f0d59b8b680” Expires:Fri, 26 May 2017 13:28:33 GMT [失效日期] server:apache tomcat nginx [哪种服务器] 说说 TCP 传输的三次握手第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。 第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。 第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。 为什么要三次握手： 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源 TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！ 四次挥手 主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段； 服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段； 服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接； 主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接； TCP 和 UDP 的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次 “对话” 才能建立起来 UDP（User Data Protocol，用户数据报协议）是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。 HTTP 和 HTTPS HTTP 协议通常承载于 TCP 协议之上，在 HTTP 和 TCP 之间添加一个安全协议层（SSL 或 TSL），这个时候，就成了我们常说的 HTTPS 默认 HTTP 的端口号为 80，HTTPS 的端口号为 443 HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。 什么是 Etag？把 Last-Modified 和 ETag 请求的 http 报头一起使用，可利用客户端（例如浏览器）的缓存。ETag 用于标识资源的状态，当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化，那么 ETag 也随之发生变化。浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间。 假如已经过期，那么浏览器将发送一个条件 GET 请求到服务器，服务器判断缓存还有效，则发送一个 304 响应，告诉浏览器可以重用缓存组件。 Expires 和 Cache-ControlExpires 用来控制缓存的失效日期 Cache-Control 用来控制网页的缓存 常见的取值有 private、no-cache、max-age、must-revalidate 等，默认为 private。 关于 Http 2.0 你知道多少？ HTTP/2 引入了 “服务端推（server push）” 的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2 提供更多的加密支持 HTTP/2 使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的 header 都只会占用很小比例的带宽。 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP，向服务器发起请求（TCP 三次握手）； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构（如 HTML 的 DOM）； 载入解析到的资源文件，渲染页面，完成。 （以上为粗略解释，每一个点都可以单拿出来详细说） 浏览器的渲染过程 浏览器请求到 HTML 代码后，在生成 DOM 的最开始阶段，并行发起 css、图片、js 的请求，无论他们是否在 HEAD 里。浏览器会将 HTML 解析成一个 DOM 树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 CSS 文件下载完成，开始构建 CSSOM 所有 CSS 文件下载完成，CSSOM 构建结束后，和 DOM 一起生成 Render Tree。 有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。 最后一步，按照算出来的规则，把内容渲染到屏幕上。 以上五个步骤前 3 个步骤因为 DOM、CSSOM、Render Tree 都可能在第一次 Painting 后又被更新多次，比如 JS 修改了 DOM 或者 CSS 属性。Layout 和 Painting 也会被重复执行，除了 DOM、CSSOM 更新的原因外，图片下载完成后也需要调用 Layout 和 Painting 来更新网页。 display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。 一个完整的 URL 包括以下几部分 http://www.hzzly.net:8080/news/index.php?boardID=5&amp;ID=24618&amp;page=1#name 协议部分 域名部分 端口部分 虚拟目录部分：从域名后的第一个 “/” 开始到最后一个 “/” 为止 文件名部分：从域名后的最后一个 “/” 开始到 “？” 为止 参数部分：从 “？” 开始到 “#” 为止之间的部分 锚部分：从 “#” 开始到最后 GET 和 POST 的区别GET：一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在 1024 字节，Get 是通过地址栏来传值。 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。（常用于发送表单数据，新建、修改等），Post 是通过提交表单来传值。 常见 HTTP 状态码 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。 2xx（成功）表示成功处理了请求的状态码。 200（成功）：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 3xx（重定向）要完成请求，需要进一步操作。 301（永久移动）：请求的网页已永久移动到新位置。 302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。 304（未修改）：自从上次请求后，请求的网页未修改过。 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。 400（错误请求）：服务器不理解请求的语法。 404（未找到）：服务器找不到请求的网页。 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。 500（服务器内部错误）：服务器遇到错误，无法完成请求。 503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。 说说网络分层里七层模型是哪七层?应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP 和 UDP） 网络层（IP） 物理和数据链路层（以太网） 讲讲 304 缓存的原理服务器首先产生 ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。 304 是 HTTP 状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 http keep-alive 与 tcp keep-alivehttp keep-alive 是为了让 tcp 活得更久一点，以便在同一个连接上传送多个 http，提高 socket 的效率。而 tcp keep-alive 是 TCP 的一种检测 TCP 连接状况的保鲜机制。 常见 web 安全及防护原理 sql 注入原理 就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。 防御手段：用token来做验证，而token只能被同域的代码访问到. XSS 指的是攻击者往 Web 页面里插入恶意 html 标签或者 javascript 代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 防御手段：过滤，把有可能出现的脚本的位置转义. CSRF CSRF 是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：1、登录受信任网站 A，并在本地生成 Cookie。2、在不登出 A 的情况下，访问危险网站 B。 算法数组去重 建一个空对象和空数组，循环遍历需要去重的数组，判断对象有没有此属性，没有的话就给对象添加此属性，并向空数组中 push 这个值。 12345678910111213141516171819//es5function unique(arr)&#123; var obj = &#123;&#125; var result = [] for(var i in arr)&#123; if(!obj[arr[i]])&#123; obj[arr[i]] = true; result.push(arr[i]); &#125; &#125; return result;&#125;// 使用 es5 过滤器arr.filter((item, index, arr) =&gt; arr.indexOf(item) === index)// 去除重复元素依靠的是 indexOf 总是返回第一个元素的位置，// 后续的重复元素位置与 indexOf 返回的位置不相等，因此被 filter 滤掉了。//es6[...new Set(arr)] 冒泡排序 相邻两个对比，最后把最大的排到了最后，重复此过程。 12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 选择排序 寻找最小的数，保存索引，然后与第一层循环其下标对于的值进行交换 12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 快速排序 选取一个记录作为中间轴，然后将比‘这个记录值’小的移到‘记录值’之前，大的移到之后，然后递归 1234567891011121314151617function quickSort(arr) &#123; if(arr.length == 0) &#123; return []; // 返回空数组 &#125; var cIndex = Math.floor(arr.length / 2); var c = arr.splice(cIndex, 1); var l = []; var r = []; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; c) &#123; l.push(arr[i]); &#125; else &#123; r.push(arr[i]); &#125; &#125; return quickSort(l).concat(c, quickSort(r));&#125; 排序算法的复杂度 复杂度从最快到最慢排序 1 logN N -&gt; 桶排序 N * logN -&gt; 快排，堆排 N * N -&gt; 冒泡，插入，选择 N * N * N N ^ x x ^ N 链表倒叙 将链表倒叙并返回倒叙后链表的头节点 1234567891011function reverse(linkList)&#123; if (!linkList) &#123; return linkList &#125; var head = linkList //当前链表的头节点 var tail = linkList.next //从第二个节点开始的子链表 var reversed = reverse(tail) //把子链表倒叙并返回子链表性的头节点（即原来的尾部） //head.next = null tail.next = head return reversed&#125; 上述代码缺点是链表长度无法超过栈的深度，超过会爆栈。 leetCode上206题 可以先算出栈的长度，超过长度分割成多个链表，倒叙每一个链表后在合并 斐波那契数列 求出斐波那契数列的第 n 项结果 123456789101112var cache = &#123; 0: 0, 1: 1&#125;;function fabonacci(n) &#123; if (typeof cache[n] === 'number') &#123; return cache[n]; &#125; var result = cache[n] = fabonacci(n - 1) + fabonacci(n - 2); return result;&#125;// fabonacci(15) 其他对前端界面工程师这个职位是怎么样理解的前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好 实现界面交互 提升用户体验 谈谈你对重构的理解在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的 API 代替旧有的框架、语言 (如 VB) 增强用户体验 通常来说对于速度的优化也包含在重构中]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flexbox 布局]]></title>
    <url>%2F2017%2F05%2F23%2Fflexbox%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[经常忘记的一个大坑，不过忘记了的话玩一遍跳青蛙游戏就想起来了2333 CSS3 弹性盒子 (Flexible Box 或 Flexbox)，是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测地运行。对于许多应用程序，弹性盒子模型提供了对块模型的改进，因为它不使用浮动，flex 容器的边缘也不会与其内容的边缘折叠。(MDN) 概念在定义方面来说，弹性布局是指通过调整其内元素的宽高，从而在任何显示设备上实现对可用显示空间最佳填充的能力。弹性容器扩展其内元素来填充可用空间，或将其收缩来避免溢出。(MDN) 而块级布局更侧重于垂直方向、行内布局更侧重于水平方向。与此相对的，弹性盒子布局算法是方向无关的。虽然块级布局对于单独一个页面来说是行之有效的，但其仍缺乏足够的定义来支持那些必须随用户代理 (user agent) 不同或设备方向从水平转为垂直等各种变化而变换方向、调整大小、拉伸、收缩的应用程序组件。 弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。这二者都是 CSS 工作组为在不同用户代理、不同书写模式和其他灵活性要求下的网页应用程序有更好的互操作性而做出的更广泛的努力的一部分。 定义在 flex 容器中默认存在两条轴，水平主轴 (main axis) 和垂直的侧轴 (cross axis)，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴，这个我们后面再说。图中是一个 flex-direction 属性为 row的弹性容器，意味着其内的弹性项目将根据既定书写模式沿主轴水平排列，其方向为元素的文本流方向，在这个例子里，为从左到右。 如何定义一个弹性盒子？1234/*使容器成为块级元素*/display: flex;/*使容器成为单个不可分的行内级元素*/display: inline-flex; 注意： 当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性都会失效。 弹性容器 (Flex container)：包含着弹性项目的父元素。通过设置 display 属性的值为 flex 或 inline-flex 来定义弹性容器。 弹性项目 (Flex item)：弹性容器的每个子元素都称为弹性项目。弹性容器直接包含的文本将被包覆成匿名弹性单元。 轴 (Axis)：每个弹性框布局包含两个轴。弹性项目沿其依次排列的那根轴称为主轴 (main axis)。垂直于主轴的那根轴称为侧轴 (cross axis)。 flex-direction 确立主轴。 justify-content 定义了在当前行上，弹性项目沿主轴如何排布。 align-items 定义了在当前行上，弹性项目沿侧轴默认如何排布。 align-self 定义了单个弹性项目在侧轴上应当如何对齐，这个定义会覆盖由 align-items 所确立的默认值。 方向 (Direction)：弹性容器的主轴起点 (main start)/ 主轴终点 (main end) 和侧轴起点 (cross start)/ 侧轴终点 (cross end) 描述了弹性项目排布的起点与终点。它们具体取决于弹性容器的主轴与侧轴中，由 writing-mode 确立的方向（从左到右、从右到左，等等）。 order 属性将元素与序号关联起来，以此决定哪些元素先出现。 flex-flow 属性是 flex-direction 和 flex-wrap 属性的简写，决定弹性项目如何排布。 行 (Line)：根据 flex-wrap 属性，弹性项目可以排布在单个行或者多个行中。此属性控制侧轴的方向和新行排列的方向。 尺寸 (Dimension)：根据弹性容器的主轴与侧轴，弹性项目的宽和高中，对应主轴的称为主轴尺寸 (main size) ，对应侧轴的称为 侧轴尺寸 (cross size)。 min-height 与 min-width 属性初始值将为 0。 flex 属性是 flex-grow、flex-shrink 和 flex-basis 属性的简写，描述弹性项目的整体的伸缩性。 布局flex-direction 决定主轴的方向 (即项目的排列方向)123.container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap 决定容器内项目是否可换行默认情况下，项目都排在主轴线上，使用 flex-wrap 可实现项目的换行。 123.container &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认值）：不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。 wrap：项目主轴总尺寸超出容器时换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow 则是 flex-direction 和 flex-wrap 的简写形式 123.container &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 默认值为: row nowrap。功能嘛，能省一行 css 代码，懒人福音？ justify-content 定义了项目在主轴的对齐方式123.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 建立在主轴为水平方向时测试，即 flex-direction: row; 为前提。 flex-start（默认值）：左对齐。 flex-end：右对齐。 center：居中。 space-between：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。 space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。 align-items 定义了项目在侧轴上的对齐方式123.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 建立在主轴为水平方向时测试，即 flex-direction: row; 为前提。 stretch（默认值）：即如果项目未设置高度或者设为 auto，将占满整个容器的高度。 flex-start：侧轴的起点对齐。 flex-end：侧轴的终点对齐。 center：侧轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 align-content 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用当 flex-wrap 设置为 nowrap 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。而 flex-wrap 设置为 wrap 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。 建立在主轴为水平方向时测试，即 flex-direction: row, flex-wrap: wrap。 123.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; stretch（默认值）：从图可以看出有三条轴线 (因为容器宽度有限)，当值为 stretch 时会三条轴线平分容器的垂直方向上的空间 (垂直方向上项目和项目间距被平分)。 flex-start：轴线全部在侧轴上的起点对齐。 flex-end：轴线全部在侧轴上的终点对齐。 center：轴线全部在侧轴上的中间对齐。 space-between：轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙。 space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。 属性有六种属性可运用在项目（item）上： order 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0123.item &#123; order: &lt;integer&gt;;&#125; 在 HTML 结构中，虽然 3，4 的 item 排在后面，但是由于分别设置了 order，使之能够排到最前面。 flex-grow 定义项目的放大比例默认值为 0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话) 如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink 定义了项目的缩小比例123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。 flex-basis 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 默认值：auto，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。 当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。 当 flex-basis 值为 0 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。当 flex-basis 值为 auto 时，则跟根据尺寸的设定值 (假如为 100px)，则这 100px 不会纳入剩余空间。 flex 三个属性的合并写法flex 是 flex-grow, flex-shrink 和 flex-basis 的简写 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。 align-self 允许单个项目有与其他项目不一样的对齐方式单个项目覆盖 align-items 定义的属性 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 这个跟 align-items 属性时一样的，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。 参考文档：css-tricks.comscotch.io进行整理总结。]]></content>
  </entry>
  <entry>
    <title><![CDATA[考察测验（二）]]></title>
    <url>%2F2017%2F05%2F19%2F%E8%80%83%E5%AF%9F%E6%B5%8B%E9%AA%8C02%2F</url>
    <content type="text"><![CDATA[某培训机构的考试题第二弹（感谢不愿透露姓名的提供者） 盒模型 box-sizing doctype ie6 有的话按照content box来渲染，又有的话按照border box来渲染 z-index position inlinebox/block/inlineblock/flex 原型链 在对象的ownprop上访问不到某个prop的时候那就到对象的proto访问同名属性 a = new A() a.proto === A.prototype 继承在js里就是用这两个特性实现的 闭包 从一个函数内部返回了一个在那个作用域内创建的函数 外部（不一定是全局）有一个变量指向一个局部作用域内的函数 在离开此作用域之后，只有这个函数能够操作此作用域内的变量 这就实现了一定程度的封装 作用域链 scope chain 某段代码在访问某个变量时，首先在当前作用域访问 如果访问不到，就在当前作用域的父作用域下访问 还是访问不到，就在父父作用域下访问 最终访问到全局作用域 Array.sort [{},{},{}].sort((a,b) = {-/0/+}) [{},{},{},’[Object object]’].sort() 多级排序 [].sort(最低优先级).sort().sort(最高优先级) 自己实现一个稳定的排序算法 第三方库（例如lodash） _.sortBy/With _.sortByAll([], ‘sum’, ‘yunwen’, ‘shuxue’) [].sort(_ =&gt; Math.radom() - 0.5) 洗牌算法 https://bost.ocks.org/mike/shuffle/compare.html 事件流（即事件模型）顺序：捕获和冒泡 此处“流”的意思是事件对象从哪个元素到哪个元素的 event passive mode 网址解析过程 可以从tcp层开始讲起，监听，连接，浏览器的解析 百度fex团队写过一篇过于详细的文章，可作为参考 解析网址的各个部分（协议，域名，端口，路径） 在hosts文件中查找域名对应的ip 没有的话请求DNS DNS是少有的基于UDP的协议，默认端口是53 速度快 包体小 连接到服务器对应的端口（http80, http442）（ssh23）（FTP21,22） 连接建立成功后，就发送http请求 服务器收到请求后，会读取url，cookie 从数据库中查询出相应的数据，读取模板，拼接html 返回给浏览器（可以说很细） 浏览器收到响应之后，通过Content-Type来决定如何渲染页面 解析html，解析过程构建dom树（又可以说一大堆东西） 解析过程中遇到了需要的外部资源（css，js，img），就会启动一个线程去下载响应的资源。但是一般浏览器针对同一服务器端口（即域）的并行下载数量为6到8个，这也就是为什么不少网站把图片，css等放在另一个域名上的原因 css的下载是不会阻塞页面渲染的 js的下载会阻塞 如果让js的下载也不阻塞页面render呢 defer，async 当css/图片下载完的时候，就需要渲染页面，会产生回流（会闪一下） 所以呢页面有时会白屏一小会，如果这个时间段css下载完成了，浏览器就一次性渲染，就不会产生闪烁了。 另一种实践就是把首页首屏直接放在style标签中内联。 taobao.com 如果浏览器中有缓存，可能就不去下载了 304协商缓存，会发请求，可能会没有响应 强缓存，只要过期时间没到，就不发请求 目录计算问题 ./a/b/../../../ac/../… 化为最简形式 面试者提了一个正则算法，多级../../的怎么优化没有考虑到 解决方案 path.resolve() （只能在node中用） path.resolve由于是用纯js写的，所以可以直接用到浏览器中，node模块是直接可以用在浏览器中 a = document.createElement(‘a’) a.href = path return a.href ,done! 正则，’..’与其前面一个路径中和，然后一致找不到可中和项为止 直接按照path.sep进行split，然后用一个栈搞定： 遇到一个内容就把他压入栈中，遇到’..’就把栈顶的元素弹出来，如果遇到’..’时栈为空，就什么也不做。拆分后的数组全部处理完就搞定了。12345678910111213141516function resolive(path) &#123; return path.split("/").reduce((arr,seg) =&gt; &#123; if (seg =='.') &#123; if ((arr[arr.length - 1] != '..' )|| (arr.length == 0)) &#123; arr.pop() &#125; else &#123; arr.push(seg) &#125; &#125; else if (seg == '.') &#123; &#125; else&#123; arr.push(seg) &#125; return arr &#125;,[]).join('/')&#125; jQuery 实现方式 rAF setTimeout 使用方式 $(el).animate({prop:targetValueprop2:’+=diffvalue’},’fastnormal/slow/500’,callback) $(el).toggle/show/hide/slideToggle/slideDown/slideUp() 动画还爱问的问题 动画队列 $(el).css({width:10,height:10}).animate({width:100}).animate({hight:100}) 前面的动画执行完才执行后面的动画。 有一个选项可以选择模式，默认是队列模式。 在animate函数增加第二个参数queue:false 服务器分辨不同的用户 就是想问cookie Set-Cookie: document.cookie = ‘cookie content’ document.cookie -&gt; all cookies Cookies: all cookies css文件标签 下载 [href$=.pdf]::after{content:url(pdf,gif);…} 事件代理/委托 原理：事件冒泡 功能：节省内存 让动态添加进来的节点也能够方便的响应事件 cookie和session session sessionStorage 浏览器关闭就会清空 HTML和XHTML的区别 XHTML是按照XML的格式来写HTML，语法限制更加严格 必须双引号 纸币和标签也必须有结束的斜杠 click可能就不符合xml规范了 清除浮动/闭合浮动 清除浮动 针对浮动元素父元素的兄弟元素 闭合浮动 针对浮动元素的父元素 Ajax XMLHttpRequest $.ajax(url,{option}) $.get/post/getScript/getJSON fetch(url,optain).then() 不能撤销 默认不发cookie http.request(url,option) xhr superagent/axious/request.js这些第三方库，在node和ajax下都封装一致 谢大喵鼎力推荐axious jQuery扩展 jQuery.extend/Object.assign/_.assign jQuery工具函数 包装对象与原始对象，及之间的转换 wrapped.valueOf() -&gt; 原始类型 Object(原始类型) -&gt; 包装类型 如何跨域 CORS JSONP 代理（很少有网站这么做） iframe也可以跨域 chrome.exe –disabled-web-security –user-data-dir=”c:/data” 类型判断 typeof instanceof a.constructor A.prototype.constructor === A Object.prototype.toString.call(obj) -&gt; ‘[Object Array]’ css reset的作用和用途 reset.css 一般来说，reset是把元素弄成一样的 normalize.css 这个是把所有元素弄到在不同浏览器里一样就好了 现在一般用这个方案 可以看一下这个项目的源代码 Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一 css3 flex布局玩转程度 flex froggy flex containter/item flex-basis/grow/shrink main/cross axis css图像精灵（Image Sprites） 图像精灵是放入一张个单独的图片中的一系列图像 包含大量图像的网页需要更长事件来下载，同时会生成多个服务器请求。 使用图像精灵将减少服务器请求数量并且节约带宽 现在更多用iconfont/svg解决 在http2shidai ,sprite应该会淡出的 css中单位px，em，rem的区别 px像素（pixel）相对长度单位。像素px是相对于显示器屏幕分辨率而言的 大小取决于 屏幕的宏观尺寸 操作系统的显示分辨率 网页的放大倍数 什么叫优雅降级和渐进增强 渐进增强 progressive enhancement: 针对低版本浏览器进行构建页面，保证最基本的功能，然后在针对高级浏览器进行效果，交互等改进和追加功能达到更好的用户体验。 如何消除一个数组里不重复的元素 数组去重 注意NaN与自己不相等 lodash.unique 如何将一个数组快速排序 排序稳定性问题 直接调用sort还是自己实现 是否考虑多级排序 对象复制 深复制/拷贝 复制对象的属性及属性的属性一直到原始类型 潜复制/拷贝 只复制对象自己一层的属性 对数组来说，a.slice()即可 对于对象来说，一次for in Own就可以了 一般情况下用递归就可以了 与isEqual差不多，只不过一个是递归对比，一个事递归复制 注意循环引用 12a = &#123;x: 1, y: 2&#125;a.z = a 上面这种情况lodash的相关函数是可以搞定的 Lodash.clone 描述一下cookies，sessionStorage和localStorage的区别？ cookie每次都会跟着请求发送，流量问题等 sessionStorage与localStorage是存在浏览器中，由js去读取 sessionStorage会在浏览器关闭时清空，localStorage这回一直等到你主动清空。 javascript事件不会事件冒泡以及委托机制 事件委托即事件代理 fiddler调试代理工具 fiddler本质上是一个http代理服务器 他会经过它的所有tcp流量都捕获并显示出来，方便调试 行内元素有哪些？块级元素有哪些? 块级元素 div,p,h1,h2,h3,h4,from,ul 行内元素 a,b,br,i,span,input,select css选择符有哪些？那些属性可以继承？ el .class #id [attr] [attr*^$~|=value] :hover:active:link:visited el.class#id[attr]:hover a b c d &gt; e &gt; f a ~ b a + b prop: inherit; 默认继承的属性 color font line-height 清除浮动有哪些方式，比较好的是哪一种 .clearfix::after {clear:both;content:’’;display:block} overflow:hidden css3实现圆角（border-radius），阴影（box-shadow）对文字加特效（text-shadow） 响应式布局用什么实现？ media query block flow min/max-width flex 如何消除一个数组里面重复的元素？ uniqed = Array.from(new Set(arr)) //es6方法 添加，删除，替换，插入到某个节点的方法 obj.appendChild(child) obj.innersetBefore(oldChild,newChild) obj.replaceChild(oldChild,newChild) obj.removeChild(child) split()/join()的区别 前者是切割成数组的形式，后者是将数组转换成字符串 this的指向 是由所在函数的调用方式决定的 “===”和”==”的不同 前者会自动转换类型，后者不会 如何阻止事件冒泡的默认机制 preventDefault() stopPropagation() return false 如何理解和应用js闭包 同源策略 一段脚本只能读取来自于同以来元的窗口和文档的属性 这里的同一来源指的是主机名，协议和端口号的组合 http状态吗有哪些？分别表示什么 100 101 200 201 301 302 304 307 401 403 404 500 501 502 网页打不开了，如何检查是哪的问题？ cmd打开 ping当前网站 是域名不存在，还是dns服务器没有连接上 打开控制台查看network,刷新页面 查看状态码，以及错误码(failed) 本地hosts是否更新 network_error 4xx/5xx 首先要做的就是打开devtools然后查看network面板 jQuery熟悉程度，它由哪些模块组成，分别的作用？ DOM操作 Ajax 动画 选择器 属性操作 内容筛选 事件 详情《锋利的JQ》一书中有介绍 你认为node可以用在哪些方面中，最近在用node做什么？ 因为js有完全的网络，文件等的访问能力，理论上可以拿来做任何其他语言可以做的事情 目前社区主要用来做 前端开发构建工具 grunt/gulp 任务运行期 task runner browserify/webpack 打包工具 uglifyjs(混淆js代码) 高性能HTTP服务器 其实并没有nginx性能高 让自己成为全栈工程师（划掉） 前端的理解 把数据展现出来，有一些交互 可以做网站，webapp 前端工程化 行内元素如何设置高度？ 设置成行内块元素 如何用js取到当前访问页面的url，如何从url中获取？之后的东西 location.href location.search .href .hash .search host protocol .pathname web安全 xss Cross Size Scripting 跨站式脚本 网页中执行了代码片段 防御手段：过滤，把有可能出现的脚本的位置转义 csrf Cross Site Request Forgery 跨站请求伪造 通过跨域的方式请求一个url 防御手段：用token来做验证，而token只能被同域的代码访问到 《Web前端黑客技术揭秘》 position的取值 absolute 绝对定位 relative 相对定位 fixed 固定定位 sticky 粘性定位 如何布局 flexbox float inline-block block content BFC(块级格式化上下文) position 如何判断一个变量是数组 Array.isArray arr instanceof Array arr.proto === Array.prototype arr.constructor === Array Object.prototype.toString.call(arr) === ‘[object Array]’ lodash中 _.isArray 十六进制转换十进制 parseInt(‘ff039B’, 16) 11 16^0 + 9 16^1 + 316^2 + 0 + 15 16^4 + 15 * 16^5 typeof 返回值有哪些？ undefined string number object boolean function symbol Function是对象还是函数，和function有什么关系 Function是函数，构造出来的对象是函数的实例 Function instanceof Object -&gt; ture Object instanceof Function -&gt; ture Object instanceof Object -&gt; ture Function instanceof Function -&gt; ture 什么是http代理 中转站，相当于路由 代为处理你的网路请求 http方法有哪些？怎么决定用哪个？ get 往url后面拼参数 SELECT post 把请求的数据放进body里去 UPDATE delete 删除服务器上某一个东西，当然你需要有权限 DELETE FROM put 往服务器放置一些东西，当然也需要有权限 INSERT INTO 其实就是增删改查 C R U D （Create Retrieve Update Delate）123DELETE /user/123 HTTP/1.1...PUT /register HTTP/1.1 $函数接收哪些类型的参数，分别有什么用？ 传css选择器，返回一个DOM的jquery对象 传HTML，包裹成一个和query对象 传js对象，$([1,2,3,4,5]) $(document.querySelectorAll(‘span’)) 传jquery对象，制造副本 如何用jQuery修改img的src .attr(‘src’, ‘xxx’) 设置textarea的值(记混) $(‘textarea’).val(‘the content’) 现在node的长期支持版本（LTS Long term Support)版本是多少？最新版本是多少？ LTS 6.9.5 最新 7.5.0 （还在飞速更新） node的异步是如何实现的 异步背后是用多线程实现的 具体实现是libuv 其实是用C++写的 跨平台的异步I/O 线程池/连接池 pool HTTP 1.1 connection: keep-alive 设计一个dialog组件 （弹出窗口） 点击按钮，绑定click事件 让dialog display: none; 切换成block弹窗的样式 屏幕居中 加上遮罩层 防止滚动（overflow:hidden） 12345678//初始接口var clicked = openDialog('are you OK?', function onClickYes()&#123; coding... &#125;, function onClickNo()&#123; coding...&#125;)//可以封装成openDialog('are you OK?').then().catch() 第三方库 smalltalk https://github.com/coderaiser/smalltalk html标签里的js,css可以从其他域加载 为什么可以呢？ 信任问题 ajax域名不同于跨域 如何热解决跨域 jsonp cors http header里添加字段 Access-Control-Allow-Origin: a.com, b.com Access-Control-Allow-Origin: * websocket 没有跨域问题 ws = newWebSock(‘ws://a.com/a/b/c’) ws.onmessage ws.send() Socked.IO 如何获取 UserAgent JS: navigator.userAgent 服务器: User-Agent头 web安全 xss csrf sql inject sql注入 事件模型，事件监听，事件捕获，事件冒泡 阻止冒泡 e.stopP的一个方法 jQuery return false mobile 图片切图 移动端小米商城 viewport rem vh/vw flex media query prototype 和proto prototype，js用来构造函数作为实例工厂 实例的proto指向构造函数的prototype 函数有prototype 实例有proto 什么是http代理 一个遵循协议的代理1234============GET http://a.com/a.html HTTP/1.1User-Agent:xxx============ 设计一个dataTable,至少包含分页，单选多选，搜索。 Dom结构 123456789101112&lt;input type="text" id="search"&gt;&lt;select name="" id=""&gt; &lt;option value=""&gt;请选择要搜索的字段&lt;/option&gt;&lt;/select&gt;&lt;table&gt; &lt;/table&gt;&lt;ul&gt; &lt;li&gt;第一页&lt;/li&gt; &lt;li&gt;第二页&lt;/li&gt; &lt;li&gt;第三页&lt;/li&gt;&lt;/ul&gt; 搜索 搜索的结果尽可能的多 分页 一页显示多少条数据 排序 按任意的列去排序 可能必须要用稳定的排序算法 大致接口设计 12345678910111213141516171819var dt = new DataTable(&#123; data:[&#123;name:'a', score: 100&#125;,&#123;name:'b', score: 90&#125;,&#123;name:'c', score: 80&#125;], data:[['a', 100], ['b', 90], ['c', 80]], tableHead: ['name', 'score'], el: '#table', theme: 'light/dark' pageSize: Infinity, pageNum: 8, pageChange: function(prevPage, nowPage)&#123; &#125;, sortBy:['abc', 'def'], search: function(text)&#123; &#125;, &#125;) dt.set('pageSize', 20) dt.on('...') 缓存 DOM缓存 排序算法的复杂度 复杂度从最快到最慢排序 1 logN N -&gt; 桶排序 N*logN -&gt; 快排，堆排 N*N -&gt; 冒泡，插入，选择 NNN N^x x ^ N 链表倒叙 将链表倒叙并返回倒叙后链表的头节点 1234567891011function reverse(linkList)&#123; if (!linkList) &#123; return linkList &#125; var head = linkList //当前链表的头节点 var tail = linkList.next //从第二个节点开始的子链表 var reversed = reverse(tail) //把子链表倒叙并返回子链表性的头节点（即原来的尾部） //head.next = null tail.next = head return reversed&#125; 上述代码缺点是链表长度无法超过栈的深度，超过会爆栈。 leetCode上206题 可以先算出栈的长度，超过长度分割成多个链表，倒叙每一个链表后在合并 inline/block/inline-block的区别 inline元素折行时折行处的垂直border是否还有 答案是没有 如果我就是想要折行处有border怎么办呢？ 面试官说他也不知道，就想问一问 其实答案是可以用box-shadow代替那一块的缺失 要是问水平方向的padding怎么办？ 再用box-shadow试试。 stream 有什么优缺点 节省内存 因为是异步的，所以空闲事件主线程可以干别的事 既然十八一个流里的内容导到另一个流里，为什么不能用for循环呢？例如如下 12345rs = fs.createReadStream('a.txt')ws = fs.createReadStream(...)for(;;)&#123; ws.write(rs.send())&#125; 答案：for循环是同步的，而流的过程是异步的，for循环执行完毕前都需要等待 iframe的各种作用 跨域 沙盒 在没有ajax的时候做不刷新页面的表单提交 svg在页面上有多少种使用方法？ 直接嵌入 img/iframe/object等标签引入 viewBOx use 都能算是不是的用法 具体看你了解多少 line-height计算方式 1.5 150% webfont闪烁加载的原因及解决方案与fonc的区别 做字体子集 把字体转成datauri内嵌到css里面 双向绑定的解决方案，如何实现 getter/setter 脏检查（dirty check），angular用的方式12345var data = &#123;&#125;dirtyCheck(data, function()&#123; console.log(8)&#125;) 如何处理异步复杂流程 在promise之前有node的domain，不过已废弃 promise，可polyfill到ie6 es7：async]]></content>
  </entry>
  <entry>
    <title><![CDATA[性能优化专题]]></title>
    <url>%2F2017%2F05%2F08%2FWeb%20performance%20optimization%2F</url>
    <content type="text"><![CDATA[一个老生常谈的问题，随着 web 技术的进步，这方面也越来越受重视。 减少HTTP请求 合并请求 css sprite 使用CDN (Content Delivery Network) 6-8, 10, 以域名为单位的同一个服务器 增加浏览器同时请求的资源数量12345678910111213141516171819202122232425262728293031 &lt;html&gt; &lt;script src="1.a.com/a.js"&gt;&lt;/script&gt; &lt;script src="1.a.com/a.js"&gt;&lt;/script&gt; &lt;script src="1.a.com/a.js"&gt;&lt;/script&gt; ... &lt;link rel="stylesheet" href="1.a.com/a.js"&gt; &lt;link rel="stylesheet" href="1.a.com/a.js"&gt; &lt;link rel="stylesheet" href="1.a.com/a.js"&gt; ... &lt;/html&gt; ``` * 使用缓存 - 各种不同类型的缓存类型 - If-Modified-Since - Last-Modified - Expores - Cache-Control* 压缩 - 在http链接上启用gzip压缩 - 用node实现一下 ```js http.createServer(function(request, response) &#123; var compressStream = gzip.createGzip() response.setHeaders(&#123; "Content-Encoding": gzip &#125;) fs.createReadStream('a.js') .pipe(compressStream) .pipe(response) &#125;) 将css文件放在页面底部 把css内联在在页面利么一般首页 将JS文件放在底部 JS的下载和运行都会阻塞/暂停页面的解析和渲染 解析：解析HTML并构建DOM树 渲染：把页面画在屏幕上 为什么JS的下载和运行都会阻塞页面 单线程 页面解析，渲染和js的运行全都是在同一个线程里执行的 执行线程跟UI线程是同一个线程 JS的代码是有可能操作DOM的1234&lt;p id="p"&gt;&lt;/p&gt;&lt;script&gt; document.getElementById('p').innerHTML = 'abc'&lt;/script&gt; 避免css表达式 width: expression(‘document.body.innerHTML’) 已过时 使用外部的JS和css 因为不同页面使用相同的个文件的话，缓存就会起作用 分赛域名(Domain sharding) 减少DNS查找 现在可以用DNS prefetch 精简JS 混淆，minifity 去掉多余的空格，注释，换行等所有不必要的内容，同时混淆代码 混淆既能减少代码体积，也能保护知识产权 1var a=(f)=&gt;function a()&#123;if(!0)&#123;console.log(!0)&#125;&#125;;a().then() uglifyjs a.js b.js 避免重定向 响应头 12HTTP/1.1 302 Removed TempLocation: c.com/a.html 即避免30x请求（缓存除外） 移除重复脚本 配置ETag ETag是一个http头，类似于文件的hash 一般来说如果服务检测到相同，就可以回复一个304请求 不同的机器上，http服务器(apache)的默认位置 会导致相同的文件内容在不同的机器上返回不同的ETag头 使ajax可以缓存 $.get(‘url’) -&gt; $.get(‘url?_=timestamp’) 不仅缓存一段内容，还缓存ajax 但要注意不要把不该缓存的内容缓存了 把资源存在localStorage里 我们写过POC imququ.com HTTP2 强制要求走https https需要证书 证书需要找响应的CA机构去买]]></content>
  </entry>
  <entry>
    <title><![CDATA[有关 JavaScript 字面量的知识]]></title>
    <url>%2F2017%2F05%2F02%2F%E5%AD%97%E9%9D%A2%E9%87%8F%E5%B8%B8%E8%AF%86%2F</url>
    <content type="text"><![CDATA[容易混淆，目前面试还没人问过。以防万一，整理。 在 JavaScript 里面，字面量包括：字符串字面量 (string literal)、数组字面量 (array literal) 和对象字面量 (object literal)，另外还有函数字面量 (function literal)。 如果以前没有接触过字面量这个词，一时间真的难以理解，定义都是写的很玄乎的，读完可能会完全不知所云，于是上网百度 + google 了一番，关于字面量方面的资料不多，写的都比较零散。 字符串字面量（String Literal）是指双引号引住的一系列字符，双引号中可以没有字符，可以只有一个字符，也可以有很多个字符（来源：互动百科）。 在编程语言中，字面量是一种表示值的记法。 示例：var test=&quot;hello world!&quot; “hello world!” 就是字符串字面量，test 是变量名。 数组字面量 (array literal)示例：1var team=["tom","john","smith","kobe"] [&quot;tom&quot;,&quot;john&quot;,&quot;smith&quot;,&quot;kobe&quot;] 是数组字面量 对象字面量 (object literal)示例：12345var person = &#123; name:"tom", age:"26", sex:"male"&#125; {name:&quot;tom&quot;,age:&quot;26&quot;,sex:&quot;male&quot;} 为对象字面量 函数字面量 (function literal)示例：12345var person = &#123; name: "tom", age: "23", tell: function()&#123;alert(name);&#125;&#125; 其中 tell 的值 function{alert(name);} 被认为是函数字面量，在调用时，函数不会执行，而是被当做数据来传递。 当然如果想把函数字面量当作函数来运行，可以使用 eval(String) 函数，让 String 里面的 JavaScript 执行运算： 看到上面的示例，也许你会想到 JSON（JavaScript Object Notation），对的，两者的确是有联系的。JSON（JavaScript 对象记法），它是一种用于描述文件和数组的记法，JSON 由 JavaScript 字面量的一个子集组成。JSON 可以用于交换数据，通常用它来替代 xml。]]></content>
  </entry>
  <entry>
    <title><![CDATA[考察测验（一）]]></title>
    <url>%2F2017%2F04%2F30%2F%E8%80%83%E5%AF%9F%E6%B5%8B%E9%AA%8C01%2F</url>
    <content type="text"><![CDATA[其实是某培训机构的考试题，不过真的挺难的，现在也没掌握全。（感谢不愿透露姓名的提供者） web worker有哪些使用场景？如何在node中使用web worker？ 1234* 高性能，多任务，高耗时操作，可以放进 worker 中执行。* 例：很多模板引擎都是把模板与数据的拼装过程放在worker中执行。* 有不少的第三方库可以用web worker* 原理是利用node的多进程来模拟worker 哪些事情不冒泡，如何解决？ 12345onfocu/onbluronerror/onload简单回答：用jQuery，有一些能够让这些事件冒泡原理：检测到相应事件后主动在其祖先元素上触发 scroll事件不能阻止有什么解决方案？ 1234567891011121314给不想滚动的元素一个 overflow: hidden；可能的问题：加上overlfow: hidden之后滚动位置的状态会丢失解决思路：在加上这个样式之前记录滚动位置，在恢复可滚动状态之后复原该滚动位置el.scrollLeft/Topel.scrollTo(x, y)A/B problem对于此题A问题：想要某些元素不对滚动事件做相应B问题：阻止scroll事件例2：A问题：想要得到一个文件名的扩展名？B问题：如何得到字符串的末尾三个字符？ domready事件与load事件有什么区别？其触发事件分别为？ 12345678DOMContentLoaded, readystatechange, readyState = 1, 3, 8loaddomready事件是在dom解析完毕后触发，包含了js的解析和执行所以我们会把js尽量放在底部如果即希望js放在head里， 又希望它不影响页面渲染，script有一个async/defer属性，加上这个属性之后。 js的下载不会阻塞页面的render了load事件是在页面中所有资源（如图片）都请求完成后触发 mouseout/over事件有什么需要注意的问题？有什么解决方案？ 1234鼠标从父元素移到子元素的过程中时，父元素就会触发out事件，子元素会触发over事件解决方案：在现代浏览器中， 用mouseenter/mouseleave。在老浏览器中，用jQuery，$el.hover(enterFn, leaveFn).mouseenter(enterFn).mouseleave(leaveFn)原理是：通过检测event.relatedTarget属性来判断 为什么说 window.onerror 不是真正的事件？ 123window.onerror = function(Error, file, line, col, row)&#123;&#125;此事件可以用来做错误上报，用ajax把错误的相关信息发送到服务器进行统计分析因为回调函数不接收事件对象 几种事件绑定方式有什么优缺点？ 123453种事件绑定方式&lt;a onclick=&quot;return false;&quot;&gt;jd&lt;/a&gt;el.onclick = function()&#123;this.event&#125;el.addEventListener(&apos;click&apos;, function(event)&#123;&#125;, true/false)IE8及以下，el.attachEvent(&apos;click&apos;, function() &#123;&#125;) 老版本IE浏览器如何添加事件？ 1el.attachEvent(&apos;click&apos;, function() &#123;&#125;) Bookmarklet是什么？可以用来干嘛？ 123书签脚本：以javascript: jscode;的格式给浏览器创建一个书签，点击书签就会在当前打开的页面中执行jscode也可以把此格式的代码直接放入地址栏回车即执行。 详述各种表单元素的DOM指针指向。 1234567891011121314from .method .action .encodeinput .formselect .optionscheckbox .checkedradio .checkedoption .selected 实现一个jQuery插件 1234567891011121314151617181920212223242526$.fn/prototype.plugin = function()&#123;&#125;$.prototype.trioleclieck = function()&#123; this是当前被包装的jQuery对象，而不是原生节点 对于一下代码this即为divs this.each(function()&#123; this.addEventListener(&apos;tripleclick&apos;, handler) &#125;) return this &lt;!-- handler.call(this[0]) --&gt;&#125;$.prototype.a$.prototype.b$.prototype.c$.extend($.prototype, &#123; a:fn, b:fn2, c:fn3,&#125;)Object.assign(target,&#123;a:&#123;b:2&#125;&#125;, source2, ...)_.merge 深合并深拷贝，浅拷贝var divs = $(&apos;div&apos;).triplecleck(function()&#123; &#125;) touchend事件有什么坑？ 12拿不到touch的点想要拿到的话只能从拿到最后一次touchmove事件上取得 更复杂的收拾检测最好是怎么做？ 12hammer.jszepyo.js 单页滚动框架有哪些？ 12fullpage.jsswiper.js 移动端更保险的是用什么事件？ 1click 移动端浏览在处理单击事件时为什么会有延迟？ 123456因为在一次单击发生后还可能发生第二次单击，浏览器并不知道首次单击的意图，只能等待一段时间后是否发生第二次单击如何消除这个延迟呢？fastclick.jshammer.js 给元素加一个css属性 或者用touchstart事件 把用户通过inputL:file选择的的图片文件放在img标签种按原始尺寸预览；画入canvas里按照缩小尺寸预览 1234567891011&lt;input type=&quot;file&quot; multiplesss&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;&lt;script&gt; fileSelect = document.querySelector(&apos;input&apos;) imgTag = document.querySelector(&apos;img&apos;) fileSelect.onchange = function() &#123; var file = this.files[0] imgTag.src = file.path &#125;&lt;/script&gt; 如何创建自定义事件并调用，另外给出相关文档 1https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events 如何得到光标在文本框中的位置？ 12el.selectionStartel.selectionEnd 什么是属性描述符？他可以用来干嘛？ 1234567891011121314151617181920212223242526272829303132property descriptor是用于描述一个属性的各项特征的对象如何获得一个属性的属性描述符？Object.getOwnPropertyDescriptor(obj, &apos;prop&apos;)Object.defineProperty(obj, &apos;prop&apos;, &#123; value:, writeable:, enumerable:, get:, set:,&#125;)Object.defineProperties(obj, &#123; prop1: &#123; value, writeable, enumerable, get, set, &#125;, prop2: &#123; &#125;&#125;)Object.create(null, &#123; a: &#123; value: 1 &#125;, b: &#123; value: 2 &#125;&#125;) 列出不能冒泡的的事件 innerHTML跟textContent有什么区别？ 12innerHTML 是直接设置元素内部的DOMtextContent 是直接设置元素的字符串内容 select元素如何支持多选？多选时如何取到所有被选中的元素？ 123456789&lt;select name=&quot;&quot; multiple id=&quot;&quot;&gt;&lt;/select&gt;select.valuefor(optain of select.options)&#123; if(optain.selected)&#123; ... &#125;&#125;Array.from(select.options)filter(it =&gt; it.selected).map(it =&gt; it.value) 请列出尽量多的es6的新语法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108反引号 var str = `abc $&#123;expr + `abc`&#125;` fn`abcdef$&#123;x&#125;$&#123;y&#125;`箭头函数 var fn = () =&gt; &#123;&#125; var fn = _ =&gt; 2 var that = this var fn = _ =&gt; (this === that) 解构赋值 var a = 1 var b = 2 var [c, d] = [a, b] var &#123;a, b&#125; = &#123; a: 1, b: 2, c: 3 &#125;形参解构 function a(&#123;x, y&#125;)&#123; console.log(x * y) &#125; a(&#123; x:1, y:8, &#125;) function b([x, y])&#123; &#125; b([1, 2, 3, 4, 5])计算属性 var obj = &#123; a: 8, &#125; obj[x*y] = 9 var obj = &#123; [expr]: 3, expr: 5, get [a]() &#123; &#125;, set [](value) &#123; &#125;, &#125;restpara 剩余参数 function(a, b, c, ...args)&#123; &#125;spread operator 数组展开 Math.max(...[1,2,3,4,5,6,7,8,9]) === Math.max(1,2,3,4,5,6,7,8,9)let 用let声明的变量不提升，TDZ， temaper Dead Zone &#123; var a = 8 ... ... ... let b =9 console.log(a * b) &#125;默认参数 function f(x = 8, y = 9, z = function()&#123;&#125;) const 阻止被const声明变量指向其他的值 const a = expr a = xxx //报错class class A &#123; //静态方法 //挂在A上 //即A.f static f()&#123; return 8 &#125; //构造函数体 //即function A()&#123;&#125; constructor() &#123; this.x = 9 this.fn = function()&#123;&#125; &#125; //实例方法 //即A.prototype.methodA methodA()&#123; &#125; &#125;forof对象方法简写对象属性简写Map/SetSymbolProxygennerator 简述你对模板引擎的理解。 1234模板+数据 =&gt; 期望的内容DOM模板一般是框架接收到被解析完成的DOM节点及数据后就地解析并渲染（in place）可以使用框架特定的方式绑定/相应事件 如何在DOM元素上触发自定义事件 实现一个lazyload功能：页面中的图片默认不显示，之只有快要滚动到视口内才加载并显示出来 12345&lt;img data-src=&quot;xx.jpg&quot; width=&quot;400&quot; height=&quot;500&quot;&gt;不能写src属性，因为浏览器读到后就会立马下载最后协商witch/height，防止图片加载前后产生的回流（reflow/relayout）（重绘repaint）el.getBoundingClientRect()//获取能够包裹元素所有矩形块的最小矩形区域el.getClientRects()//获取组成元素的各个矩形块，一般为内联元素 写出各个不同类型的dom元素的原生api：普通元素，表单元素等等。 12345678910el .childNodes .children .first/lastChild .first/lastElementChild .parentNode/Element .insertBefore(child, newChild) .appendChild(newChild) .get/setAttribute(&apos;attr&apos;, value) .addEventListener() 想要拦截用户的粘贴事件并对粘贴的内容做过滤，应该如何实现？说出思路 12345zeroClipboard.js 点击自动粘贴========监听粘贴事件发生时读取剪切板数据，preventDefault()过滤读取到的剪切板内容使用selectStart/End来替换选中的文本，达到类似于粘贴的效果 说出css常用的单位有哪些，以及他们的意义。 1234567891011相对单位 px =&gt; css像素。一般来说页面，屏幕，等全部一比一的时候一个物理像素就是1px。但是页面放大或者缩小，或者分辨率跟屏幕物理分辨率不同，就不一定是了。 em =&gt; 字号大小 rem =&gt; html（根元素）元素的字号大小 vh/vw =&gt;视口宽高的百分之一，包含滚动条 ex =&gt; x字符的高度 ch =&gt; 0字符的宽度 百分比 绝对单位 cm/pt/in =&gt; 虽然理论上是绝对单位,但是大多数时候都不不符合实际长度。 polyfill、与shim的区别是什么？ 123456polyfill 能够把新的api在老浏览器里完全实现，这个实现就称为polyfillshim 垫片 能够让新的api在老的浏览器中不报错，这个实现就称为shim es5-shim 详述Node require函数查找模块文件的过程 1234567891011内置模块，直接返回如果参数像路径（以点开头），则相对于当前文件所在目录查找 如果这个路径是一个文件，直接加载文件本身/.js/.json/.node 如果这个路径是一个文件夹 如果文件夹内没有package.json 则加载文件夹内的index.js/json/node 如果文件夹内有package.json 则加载json.main字段对应的文件如果即不像路径，又不是内置模块，则是第三方模块。在当前及祖先文件夹的 node_modules 文件夹内部找与模块名相同的文件夹，再读取package.json。https://nodejs.org/dist/latest-v7.x/docs/api/modules.html#modules_all_together 用npm安装模块时，有无-g的区别在哪里？ 12345678910有-g的时候是全局安装 安装在C:\Users\ 同事，一般来说会安装一个命令行工具无-g时安装在当前目录的node_modulules文件夹里npm install把当前文件夹视作一个node项目按照语义化版本号要求，安装package.json下的dependences字段下的所有第三方模块^x.y.z =&gt; x不可动（默认）~x.y.z =&gt; x, y都不可动 2.71828的二进制形式时多少/（尝试手动转换，二进制同样精确到小数点后5位） 123410.1011010.71828 * 2 1.xx小数部分*2取整 2.71828用IEEE754标准使用32位二进制表示时在计算机中的存储是什么样的？给出内存中的二进制形式 1234510.101101111110000100110010101101010101111011110011.010110111111000010011001010110101010111101111001 * 2 ^ 10[10000000]0101101111110000100110001000000 00101101 11111000 01001100 计算中为什么要便用补码来表示负数？ 12补码能够让符号位也参与运算原理这是同余理论 简述对数据库系统以下各个概念的理解：数据库，表，主键，外键，事务，脱敏，连接，视图，索引，聚集。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849数据库 - 相当于一个excel文件表 - 相当于里面的一个sheet主键 - 表的某一列的值不为空且唯一。也就是说知道主键就可以定位表中的特定的某“一”行外键 - 表中的某一列的数据来自另一张表（也可以是本表）的主键事物 - transtation 交易 一手交钱一手交货。数据库西永需要的能够以保证操作的ACID：原子性脱敏 - 连接 - 将两张表按照制定的规则生成一张新表。视图 - 虚表由一个选择结果组成的表。索引 - 可以为某一列或者多列创建索引，使查找更快。索引会占用空间吗同时也需要与表的内容包吃一致，所以每次修改表的内容时，索引也会相应的修改，所以是会花时间的，但其会让查找变得非常快。聚集 - aggregatehttps://www.sqlite.org/lang_aggfunc.htmlsqlite&gt; select * from user;username age gender---------- ---------- ----------a 67 1b 67 0c 5 1d 23 1e 39 0f 30 1g 34 0sqlite&gt; SELECT avg(age), gender from user ;avg(age) gender---------------- ----------37.8571428571429 0sqlite&gt; SELECT avg(age), gender from user group by gender;avg(age) gender---------------- ----------46.6666666666667 031.25 1sqlite&gt; SELECT sum(age), gender from user group by gender;sum(age) gender---------- ----------140 0125 1sqlite&gt; SELECT count(age), gender from user group by gender;count(age) gender---------- ----------3 04 1sqlite&gt; SELECT count(age), gender from user where gender=1 group by gender;count(age) gender---------- ----------4 1sqlite&gt; SELECT count(age) as count, gender from user where gender=1 group by gender;count gender---------- ----------4 1 Seajs能够在浏览器中异步加载文件但又同步require的原理是什么？ 12345其实是把所有的依赖都下载好之后才开始执行的那如何在不执行的情况下就分析好依赖呢？其实是八行书toString然后用正则匹配出内部的require语句所以，seajs/requirejs中的require语句中只能写字符串常量seajs.use(&apos;a/&apos; + &apos;jquery.js&apos;) 如何编写一个自己的Node模块？其原理是什么？需要注意些什么？ 12345678910111213var fs = require(&apos;fs&apos;)exports.a = xxxexports.b = yyymoudule.exports = zzz //保险的做法exports = 8//错误原理就是module其实是外界传入的一个对象，我们的模块只是在修改这个对象，修改完成之后结束了，外界就能改得到被我们修改过的对象。而我们是在一个闭包（我们的代码被主动包裹在一个闭包内执行）里修改的这个对象嘛所以不会产生全局变量污染的问题。(function(require, moudule, exports, __dirname, __filename)&#123; mycode... &#125;)() .gitignore文件的作用是什么？ 12345让git忽略对某些文件的主动跟踪是一个文本文件，一行一个路径其可以存在于项目中的任何一个文件夹中。可以出现多次，里面的路径都是相对于其所在的文件夹的。想要把一个文件夹提交上去，但是又要忽略里面所有文件 简述你对多线程的理解，以及其与异步的关系 12多线程就是从宏观角度，有多段代码同时执行。触发了异步任务之后，其实异步的任务就是在另一个线程中执行的。执行完成之后通知主线程（或触发异步任务的线程）。 简述你对事件循环的理解 123浏览器会每隔一段时间去检查任务队列中是否有需要执行的任务，有的话，就执行。两次事件循环之间大约为4毫秒的间隔。process.nextTick(fn)把fn放在当次事件循环之后调用，而不是下一次事件循环里面 简述你对tcp协议及http协议的理解，说解释tcp与http的区别 1234567891011TCP就是字节流协议，连接建立好之后，就可以发送或接收任何字节流。http是基于TCP的应用层协议http协议只能按照指定的格式在tcp层发送字节流================GET / HTTP / 1.1Host: www.example.com----------------HTTP /1.1 200 OKContent-Type: text/html; charset=utf8&lt;!DOCTYPE html&gt;================ host文件是干嘛用的？ 1234567本机DNS，如果某个域名条件会出现在hosts文件中，则不会向DNS服务器询问其IP地址。在一些开发中，可以用来做调试用。a.com -&gt; 1.2.3.4 //a.com的真实ip地址a.com 127.0.0.1 //写在hosts中的条目最终访问的的就是127.0.0.1这个ip地址的服务器然后可以在127.0.0.1上搭一个跟线上一样的服务器，就可以本地调试了。 调度复杂的同步异步混合代码需要注意什么？ 12时序。即哪段代码先执行哪段代码后执行。解决方案：promise cookie是什么？ 1234cookie就是服务器通过http头（Set-Cookie）或者JS通过document.cookie设置的保存到浏览器的一段文本内容，会在浏览器每次发送请求时都通过cookie头带上并发送到服务器。标识用户。一半来说用户登陆之后，服务器就会下发一段加了密的cookie。 JSONP的原理是？ 1234567891011121314151617181920212223242526272829JSON Padding用途：合理的跨域访问。a.com:&lt;script&gt;function jsonp12345(data)&#123;&#125;&lt;/script&gt;&lt;script src=&quot;b.com/data?x=1&amp;y=2&amp;callback=jsonp12345&quot;&gt;&lt;/script&gt;&lt;!-- jsonp12345(&#123;&#125;) --&gt;&lt;script src=&quot;aaa.com/&quot;&gt;&lt;/script&gt;&lt;img src=&quot;xxxx.com&quot; alt=&quot;&quot;&gt;不能发POST请求能不能处理错误script.onerrorwindow.onerrorimg.onerrorscript.onerror能不能处理超时的请求呢？？？xhrsetTimeout(fn, timeoutDuration) 作业：实现JSONP请求的超时处理，调用方式如下：jsonp(‘path?querystring&amp;callback=?’, onsuccess, ontimeout)123456789101112131415161718192021222324252627282930313233343536function jsonp(url, ansuccess, ontimeout) &#123; var loaded = false var timeout = false var globalCallbackName = '__jsonp__callback__' + Date.now() + Math.random() window.[globalCallbackName] = function(data) &#123; if (!timeout) &#123; onsuccess(data) &#125; &#125; url = url + '&amp;callback=' + globalCallbackName //path?a=b&amp;c=d&amp;callback=__jsonp__callback__ var scripttag = document.createElement('script') scriptTag.onload = function()&#123;//加载并执行完成后触发 document.body.removeChild(scriptTag) delete window[globalCallbackName] loaded = true &#125; scriptTag.src = url document.body.appendChild(scriptTag) setTimeOut(function()&#123; if (!loaded) &#123; onTimeout() timeout = true &#125; &#125;,5e3)&#125;__jsonp__callback__(&#123; data: &#123; name: 'xieran', age: 30, &#125; &#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[常见 CSS 中两列自适应布局]]></title>
    <url>%2F2017%2F04%2F22%2F%E5%B8%B8%E8%A7%81%E4%B8%A4%E5%88%97CSS%E4%B8%80%E8%BE%B9%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[RT，就是个两列布局，左侧定宽，右侧自适应的几种方法。 首先，先看一下初始条件。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="left l"&gt;0&lt;/div&gt; &lt;div class="right r"&gt;1~~~&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789.left &#123; width: 100px; height: 200px; background-color: rgba(255, 0, 0, 0.3);&#125;.right &#123; height: 100px; background-color: rgba(0, 255, 0, 0.3);&#125; 就是这样的简单的两个块级元素，设置了点初始条件，方便观察。 固定区域浮动，自适应区域不设置宽度但设置 marginCSS 中增加以下代码： 123456.l &#123; flow: left;&#125;.r &#123; margin-left: 100px;&#125; 需要注意的是，当右侧的块忘记设定 margin-left 时，右侧的块会与左侧的块重合，但是文字不会重合。 固定区域使用定位，自适应区域不设置宽度但设置 marginCSS 中增加以下代码： 123456.l &#123; position: absolute;&#125;.r &#123; margin-left: 100px;&#125; 使用 table-cellCSS 中增加以下代码： 12345678910body &#123; display: table; width: 100%;&#125;.l &#123; display: tabel-cell;&#125;.r &#123; display: tabel-cell;&#125; 注意：这个时候已经设定的右侧块的高度（height: 100px;）会失效。 使用 CSS 弹性盒子（flexbox）CSS 中增加以下代码： 1234567body &#123; display: flex; flex-flow: row;&#125;.r &#123; flex: 1;&#125; 右侧 div 的 flex: 1，这里很关键，1 会将剩余宽度全部占满，即如果左侧宽度发生改变的话，右侧能够自适应，而不用像第一种方法那样 margin-left 也要修改。]]></content>
  </entry>
  <entry>
    <title><![CDATA[芋头君 3.18 面试 Live 总结]]></title>
    <url>%2F2017%2F04%2F16%2F%E8%8A%8B%E5%A4%B4%E5%90%9B3.18%E9%9D%A2%E8%AF%95Live%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[知乎又送优惠卷系列，感觉挺好的不做个笔记浪费了。 准备工作 闭包作用域 递归 可能穿插一些基本的点，例如判断一个字符串是数组 正则表达式 变量的作用域，对象的作用域（call，apply） ES6特性 CSS盒模型 写一个动画（手写，不管用什么形式，让元素动起来就行） 清除浮动的方式（手写、多选） 多列布局的方式（手写、多选） 考察是否了解flexbox HTTP，网络协议 例：从网址输入URL到显示页面经历了什么过程 跨域 MVVM是一种怎样的分成，扮演了一种怎样的角色 一年的工作经验十分尴尬，跟应届生差不多，尽量多花时间再自我成长上。 面试题HTML&amp;CSS（分别 10 分） 一个 div，宽度是 100px，此时设置 padding 是 20px，添加一个什么 css 属性可以让 div 的实际宽度仍然保持在 100px，而不是 140px？ 清除浮动的方式，提供尽可能多的方案。 如何让两个 div 分别以 40% 和 60% 的比例排在一行内，提供尽可能多的方案。 如何用 css 实现一个 div 的一秒内向右平滑移动 100px 的动画 . localStorage，sessionStorage，Cookie 的区别和用途。 正则题123var string = "我的账户余额：2,235,467.20";console.log(?);// 请用 js 计算出我到底有多少钱（输出 Number 类型数字，代码尽量简洁，考虑通用情况） 作用域12345678function person() &#123; return this.name;&#125;var someOne = &#123; name: 'Jenny', age: 18&#125;;// 此处如何输出'Jenny' 语法题有一个合法的 JSON 对象（即不包含函数等值的对象），设计一个函数，取出该对象内所有 key 为 “id” 并且其值不为对象、数组的值，装入一个数组并返回。12345678910111213141516function extractIds(data) &#123; // implement&#125;样例数据：var data = &#123; id: 1, items: [ &#123; id: 2 &#125;, &#123; item: 3, id: [ &#123; id: 4 &#125;, &#123; id: 5 &#125; ]&#125; ]&#125;;extractIds(data); // should return [ 1, 2, 4, 5 ] 闭包下面五段代码分别输出什么？并且什么时候输出什么？123456789101112131415161718192021222324252627for(var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125;for(var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;for(var i = 0; i &lt; 5; i++) &#123; (function() &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;for(var i = 0; i &lt; 5; i++) &#123; setTimeout((function(i) &#123; console.log(i); &#125;)(i), i * 1000);&#125; 创建一个二进制相加函数，根据传入的两个二进制数字符串返回一个相加的十进制的结果。123456789101112/** @param &#123;String&#125; a number a* @param &#123;String&#125; b number b* return &#123;Number&#125; the result*/function calculate(num1, num2)&#123; // implement here&#125;结果样例：calculate("10", "10") // =&gt; 4calculate("10", "0") // =&gt; 2calculate("101", "10") // =&gt; 7]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式相关]]></title>
    <url>%2F2017%2F04%2F13%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[一个死活记不住的系列（死 正则表达式是一种查找以及字符串替换操作，在文本编辑器中广泛使用，比如正则表达式被用于： 检查文本中是否含有指定的特征词 找出文中匹配特征词的位置 从文本中提取信息，比如：字符串的子串 修改文本 而关于正则表达式本身的语法，建议阅读前人总结的灰常详细的资料：正则表达式 30 分钟入门教程，非常详细，本次主要整理正则表达式在 JavaScript 中的方法及应用。 正则表达式是用于匹配字符串中字符组合的模式（MDN）。在 JavaScript 中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。 RegExp 的方法RegExp 对象有 3 个方法：test()、exec() 以及 compile()。 test()：检索字符串中的指定值。返回值是布尔值。 exec()：返回一个数组，数组中的第一个条目是第一个匹配，其他的是反向引用 compile()：既可以改变检索模式，也可以添加或删除第二个参数。 exec()方法： 12345678/* 统计子字符串出现的所有位置*/function count(str)&#123; var b,r = /def/g; while(b = r.exec(str))&#123; console.log(b); &#125;&#125;count('abcdefabcdefabcdefabcdef'); 12345// 输出[ &apos;def&apos;, index: 3, input: &apos;abcdefabcdefabcdefabcdef&apos; ][ &apos;def&apos;, index: 9, input: &apos;abcdefabcdefabcdefabcdef&apos; ][ &apos;def&apos;, index: 15, input: &apos;abcdefabcdefabcdefabcdef&apos; ][ &apos;def&apos;, index: 21, input: &apos;abcdefabcdefabcdefabcdef&apos; ] String 对象中的正则表达式方法 match(pattern)：返回 pattern 中的子串或 null replace(pattern, replacement)：用 replacement 替换 pattern search(pattern)：返回字符串中 pattern 开始位置 split(pattern)：返回字符串按指定 pattern 拆分的数组 match()方法： 12345/*使用 match 方法获取获取匹配数组*/ var pattern = /box/ig;//全局搜索 var str = 'This is a Box!,That is a Box too'; console.log(str.match(pattern)); //匹配到两个 Box,Boxconsole.log(str.match(pattern).length);//获取数组的长度 123// 输出[&quot;Box&quot;, &quot;Box&quot;]2 replace()方法： 1234/*使用 replace 替换匹配到的数据*/var pattern = /box/ig;var str = 'This is a Box!,That is a Box too'; console.log(str.replace(pattern, 'Cat'));//将 Box 替换成了 Cat 12// 输出This is a Cat!,That is a Cat too search()方法： 1234/*使用 search 来查找匹配数据*/var pattern = /box/ig;var str = 'This is a Box!,That is a Box too'; console.log(str.search(pattern));//查找到返回位置,否则返回 -1 12// 输出10 split()方法： 1234/*使用 split 拆分成字符串数组*/var pattern = / /ig;var str = 'This is a Box!,That is a Box too'; console.log(str.split(pattern));//将空格拆开分组成数组 12// 输出[&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;Box!,That&quot;, &quot;is&quot;, &quot;a&quot;, &quot;Box&quot;, &quot;too&quot;] 应用篇字符串去重： 12345//方案一'aaabbbccccdeeffkkkxxxmm'.replace(/(\w)\1+/g, '$1')//方案二'aaabbbccccdeeffkkkxxxmm'.replace(/(.)(?=\1)/g, '') 任意一个字符串只保留后四位，其余用 * 替代： 1234567891011//方案一'4556364607935616'.replace(/\w*(?=....)/, function(match) &#123; return match.replace(/./g, '*')&#125;)//方案二'4556364607935616'.replace(/\w*(?=....)/, function(match) &#123; return '*'.repeat(match.length)//方案三'4556364607935616'.replace(/.(?=....)/g, '*') 找出字符串中不止一次出现的字符个数： 1('kdfaxffsaacadfaaddfk'.toUpperCase().split('').sort().join('').match(/(\w)\1+/g) || []).length 数字为ASCII码，将其转换成字母并且将第二个字母与最后一个字母位置调换： 123456//例：'72olle 103doo 100ya' =&gt; 'hello good day'//方案一'72olle 103doo 100ya'.split(' ').map(w =&gt; w.replace(/\d+/, a =&gt; String.fromCharCode(a))).map(w =&gt; w.replace(/(.)(.)(.*)(.)/, '$1$4$3$2')).join(' ')//方案二'72olle 103doo 100ya'.replace(/\d+/g, a =&gt; String.fromCharCode(a)).replace(/\b(\w)(\w)(\w*?)(\w)\b/g, '$1$4$3$2') 驼峰式字符串去数字改下划线连接： 12345//方案一'myCame33lCas3edStri3ng'.replace(/\d/g, '').replace(/(?!^)[A-Z]/g, '-$&amp;').toLowerCase()//方案二'myCame33lCas3edStri3ng'.replace(/\d/g, '').replace(/(?=(?!^)[A-Z])/g, '-').toLowerCase() 文件路径操作。分别拿到文件夹的扩展名，文件名，以及文件夹名： 123456789101112131415161718192021//方案一'/Users/person1/Pictures/house.png'.match(/(.*)\/(\w+)\.(\w+)/)//方案二class FileMaster &#123; constructor(path) &#123; this.parts = path.match(/(.*)\/(\w+)\.(\w+)/) &#125; extension() &#123; return this.parts[3] &#125; filename() &#123; return this.parts[2] &#125; dirpath() &#123; return this.parts[1] + '/' &#125;&#125; 去掉所有单词后面的感叹号，前面的感叹号不去掉： 12345678910//例：'!!!Hi !!hi!!! !hi!!!!!' =&gt; !!!Hi !!hi !hi//方案一'!!!Hi !!hi!!! !hi!!!!!'.replace(/!+(?=( |$))/g, '')//方案二'!!!Hi !!hi!!! !hi!!!!!'.replace(/(\w)!+/g, '$1')//方案二'!!!Hi !!hi!!! !hi!!!!!'.replace(/\b!+/g, '')]]></content>
  </entry>
</search>
